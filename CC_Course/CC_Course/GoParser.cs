//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Grammar/GoParser.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class GoParser : GoParserBase {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		BREAK=1, DEFAULT=2, FUNC=3, INTERFACE=4, SELECT=5, CASE=6, DEFER=7, GO=8, 
		MAP=9, STRUCT=10, CHAN=11, ELSE=12, GOTO=13, PACKAGE=14, SWITCH=15, CONST=16, 
		FALLTHROUGH=17, IF=18, RANGE=19, TYPE=20, CONTINUE=21, FOR=22, IMPORT=23, 
		RETURN=24, VAR=25, NIL_LIT=26, IDENTIFIER=27, L_PAREN=28, R_PAREN=29, 
		L_CURLY=30, R_CURLY=31, L_BRACKET=32, R_BRACKET=33, ASSIGN=34, COMMA=35, 
		SEMI=36, COLON=37, DOT=38, PLUS_PLUS=39, MINUS_MINUS=40, DECLARE_ASSIGN=41, 
		ELLIPSIS=42, LOGICAL_OR=43, LOGICAL_AND=44, EQUALS=45, NOT_EQUALS=46, 
		LESS=47, LESS_OR_EQUALS=48, GREATER=49, GREATER_OR_EQUALS=50, OR=51, DIV=52, 
		MOD=53, LSHIFT=54, RSHIFT=55, BIT_CLEAR=56, UNDERLYING=57, EXCLAMATION=58, 
		PLUS=59, MINUS=60, CARET=61, STAR=62, AMPERSAND=63, RECEIVE=64, DECIMAL_LIT=65, 
		BINARY_LIT=66, OCTAL_LIT=67, HEX_LIT=68, FLOAT_LIT=69, DECIMAL_FLOAT_LIT=70, 
		HEX_FLOAT_LIT=71, IMAGINARY_LIT=72, RUNE_LIT=73, BYTE_VALUE=74, OCTAL_BYTE_VALUE=75, 
		HEX_BYTE_VALUE=76, LITTLE_U_VALUE=77, BIG_U_VALUE=78, RAW_STRING_LIT=79, 
		INTERPRETED_STRING_LIT=80, WS=81, COMMENT=82, TERMINATOR=83, LINE_COMMENT=84, 
		WS_NLSEMI=85, COMMENT_NLSEMI=86, LINE_COMMENT_NLSEMI=87, EOS=88, OTHER=89;
	public const int
		RULE_sourceFile = 0, RULE_packageClause = 1, RULE_importDecl = 2, RULE_importSpec = 3, 
		RULE_importPath = 4, RULE_declaration = 5, RULE_constDecl = 6, RULE_constSpec = 7, 
		RULE_identifierList = 8, RULE_expressionList = 9, RULE_typeDecl = 10, 
		RULE_typeSpec = 11, RULE_aliasDecl = 12, RULE_typeDef = 13, RULE_typeParameters = 14, 
		RULE_typeParameterDecl = 15, RULE_typeElement = 16, RULE_typeTerm = 17, 
		RULE_functionDecl = 18, RULE_methodDecl = 19, RULE_receiver = 20, RULE_varDecl = 21, 
		RULE_varSpec = 22, RULE_block = 23, RULE_statementList = 24, RULE_statement = 25, 
		RULE_simpleStmt = 26, RULE_expressionStmt = 27, RULE_sendStmt = 28, RULE_incDecStmt = 29, 
		RULE_assignment = 30, RULE_assign_op = 31, RULE_shortVarDecl = 32, RULE_labeledStmt = 33, 
		RULE_returnStmt = 34, RULE_breakStmt = 35, RULE_continueStmt = 36, RULE_gotoStmt = 37, 
		RULE_fallthroughStmt = 38, RULE_deferStmt = 39, RULE_ifStmt = 40, RULE_switchStmt = 41, 
		RULE_exprSwitchStmt = 42, RULE_exprCaseClause = 43, RULE_exprSwitchCase = 44, 
		RULE_typeSwitchStmt = 45, RULE_typeSwitchGuard = 46, RULE_typeCaseClause = 47, 
		RULE_typeSwitchCase = 48, RULE_typeList = 49, RULE_selectStmt = 50, RULE_commClause = 51, 
		RULE_commCase = 52, RULE_recvStmt = 53, RULE_forStmt = 54, RULE_forClause = 55, 
		RULE_rangeClause = 56, RULE_goStmt = 57, RULE_type_ = 58, RULE_typeArgs = 59, 
		RULE_typeName = 60, RULE_typeLit = 61, RULE_arrayType = 62, RULE_arrayLength = 63, 
		RULE_elementType = 64, RULE_pointerType = 65, RULE_interfaceType = 66, 
		RULE_sliceType = 67, RULE_mapType = 68, RULE_channelType = 69, RULE_methodSpec = 70, 
		RULE_functionType = 71, RULE_signature = 72, RULE_result = 73, RULE_parameters = 74, 
		RULE_parameterDecl = 75, RULE_expression = 76, RULE_primaryExpr = 77, 
		RULE_conversion = 78, RULE_operand = 79, RULE_literal = 80, RULE_basicLit = 81, 
		RULE_integer = 82, RULE_operandName = 83, RULE_qualifiedIdent = 84, RULE_compositeLit = 85, 
		RULE_literalType = 86, RULE_literalValue = 87, RULE_elementList = 88, 
		RULE_keyedElement = 89, RULE_key = 90, RULE_element = 91, RULE_structType = 92, 
		RULE_fieldDecl = 93, RULE_string_ = 94, RULE_embeddedField = 95, RULE_functionLit = 96, 
		RULE_index = 97, RULE_slice_ = 98, RULE_typeAssertion = 99, RULE_arguments = 100, 
		RULE_methodExpr = 101, RULE_eos = 102;
	public static readonly string[] ruleNames = {
		"sourceFile", "packageClause", "importDecl", "importSpec", "importPath", 
		"declaration", "constDecl", "constSpec", "identifierList", "expressionList", 
		"typeDecl", "typeSpec", "aliasDecl", "typeDef", "typeParameters", "typeParameterDecl", 
		"typeElement", "typeTerm", "functionDecl", "methodDecl", "receiver", "varDecl", 
		"varSpec", "block", "statementList", "statement", "simpleStmt", "expressionStmt", 
		"sendStmt", "incDecStmt", "assignment", "assign_op", "shortVarDecl", "labeledStmt", 
		"returnStmt", "breakStmt", "continueStmt", "gotoStmt", "fallthroughStmt", 
		"deferStmt", "ifStmt", "switchStmt", "exprSwitchStmt", "exprCaseClause", 
		"exprSwitchCase", "typeSwitchStmt", "typeSwitchGuard", "typeCaseClause", 
		"typeSwitchCase", "typeList", "selectStmt", "commClause", "commCase", 
		"recvStmt", "forStmt", "forClause", "rangeClause", "goStmt", "type_", 
		"typeArgs", "typeName", "typeLit", "arrayType", "arrayLength", "elementType", 
		"pointerType", "interfaceType", "sliceType", "mapType", "channelType", 
		"methodSpec", "functionType", "signature", "result", "parameters", "parameterDecl", 
		"expression", "primaryExpr", "conversion", "operand", "literal", "basicLit", 
		"integer", "operandName", "qualifiedIdent", "compositeLit", "literalType", 
		"literalValue", "elementList", "keyedElement", "key", "element", "structType", 
		"fieldDecl", "string_", "embeddedField", "functionLit", "index", "slice_", 
		"typeAssertion", "arguments", "methodExpr", "eos"
	};

	private static readonly string[] _LiteralNames = {
		null, "'break'", "'default'", "'func'", "'interface'", "'select'", "'case'", 
		"'defer'", "'go'", "'map'", "'struct'", "'chan'", "'else'", "'goto'", 
		"'package'", "'switch'", "'const'", "'fallthrough'", "'if'", "'range'", 
		"'type'", "'continue'", "'for'", "'import'", "'return'", "'var'", "'nil'", 
		null, "'('", "')'", "'{'", "'}'", "'['", "']'", "'='", "','", "';'", "':'", 
		"'.'", "'++'", "'--'", "':='", "'...'", "'||'", "'&&'", "'=='", "'!='", 
		"'<'", "'<='", "'>'", "'>='", "'|'", "'/'", "'%'", "'<<'", "'>>'", "'&^'", 
		"'~'", "'!'", "'+'", "'-'", "'^'", "'*'", "'&'", "'<-'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "BREAK", "DEFAULT", "FUNC", "INTERFACE", "SELECT", "CASE", "DEFER", 
		"GO", "MAP", "STRUCT", "CHAN", "ELSE", "GOTO", "PACKAGE", "SWITCH", "CONST", 
		"FALLTHROUGH", "IF", "RANGE", "TYPE", "CONTINUE", "FOR", "IMPORT", "RETURN", 
		"VAR", "NIL_LIT", "IDENTIFIER", "L_PAREN", "R_PAREN", "L_CURLY", "R_CURLY", 
		"L_BRACKET", "R_BRACKET", "ASSIGN", "COMMA", "SEMI", "COLON", "DOT", "PLUS_PLUS", 
		"MINUS_MINUS", "DECLARE_ASSIGN", "ELLIPSIS", "LOGICAL_OR", "LOGICAL_AND", 
		"EQUALS", "NOT_EQUALS", "LESS", "LESS_OR_EQUALS", "GREATER", "GREATER_OR_EQUALS", 
		"OR", "DIV", "MOD", "LSHIFT", "RSHIFT", "BIT_CLEAR", "UNDERLYING", "EXCLAMATION", 
		"PLUS", "MINUS", "CARET", "STAR", "AMPERSAND", "RECEIVE", "DECIMAL_LIT", 
		"BINARY_LIT", "OCTAL_LIT", "HEX_LIT", "FLOAT_LIT", "DECIMAL_FLOAT_LIT", 
		"HEX_FLOAT_LIT", "IMAGINARY_LIT", "RUNE_LIT", "BYTE_VALUE", "OCTAL_BYTE_VALUE", 
		"HEX_BYTE_VALUE", "LITTLE_U_VALUE", "BIG_U_VALUE", "RAW_STRING_LIT", "INTERPRETED_STRING_LIT", 
		"WS", "COMMENT", "TERMINATOR", "LINE_COMMENT", "WS_NLSEMI", "COMMENT_NLSEMI", 
		"LINE_COMMENT_NLSEMI", "EOS", "OTHER"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GoParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static GoParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public GoParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public GoParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class SourceFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PackageClauseContext packageClause() {
			return GetRuleContext<PackageClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(GoParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ImportDeclContext[] importDecl() {
			return GetRuleContexts<ImportDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportDeclContext importDecl(int i) {
			return GetRuleContext<ImportDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeclContext[] functionDecl() {
			return GetRuleContexts<FunctionDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeclContext functionDecl(int i) {
			return GetRuleContext<FunctionDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MethodDeclContext[] methodDecl() {
			return GetRuleContexts<MethodDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MethodDeclContext methodDecl(int i) {
			return GetRuleContext<MethodDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		public SourceFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sourceFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSourceFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSourceFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSourceFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SourceFileContext sourceFile() {
		SourceFileContext _localctx = new SourceFileContext(Context, State);
		EnterRule(_localctx, 0, RULE_sourceFile);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 206;
			packageClause();
			State = 207;
			eos();
			State = 213;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IMPORT) {
				{
				{
				State = 208;
				importDecl();
				State = 209;
				eos();
				}
				}
				State = 215;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 225;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 34668552L) != 0)) {
				{
				{
				State = 219;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
				case 1:
					{
					State = 216;
					functionDecl();
					}
					break;
				case 2:
					{
					State = 217;
					methodDecl();
					}
					break;
				case 3:
					{
					State = 218;
					declaration();
					}
					break;
				}
				State = 221;
				eos();
				}
				}
				State = 227;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 228;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PackageClauseContext : ParserRuleContext {
		public IToken packageName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(GoParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public PackageClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterPackageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitPackageClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackageClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PackageClauseContext packageClause() {
		PackageClauseContext _localctx = new PackageClauseContext(Context, State);
		EnterRule(_localctx, 2, RULE_packageClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230;
			Match(PACKAGE);
			State = 231;
			_localctx.packageName = Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPORT() { return GetToken(GoParser.IMPORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ImportSpecContext[] importSpec() {
			return GetRuleContexts<ImportSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportSpecContext importSpec(int i) {
			return GetRuleContext<ImportSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ImportDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterImportDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitImportDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportDeclContext importDecl() {
		ImportDeclContext _localctx = new ImportDeclContext(Context, State);
		EnterRule(_localctx, 4, RULE_importDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 233;
			Match(IMPORT);
			State = 245;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
			case DOT:
			case RAW_STRING_LIT:
			case INTERPRETED_STRING_LIT:
				{
				State = 234;
				importSpec();
				}
				break;
			case L_PAREN:
				{
				State = 235;
				Match(L_PAREN);
				State = 241;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (((((_la - 27)) & ~0x3f) == 0 && ((1L << (_la - 27)) & 13510798882113537L) != 0)) {
					{
					{
					State = 236;
					importSpec();
					State = 237;
					eos();
					}
					}
					State = 243;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 244;
				Match(R_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportSpecContext : ParserRuleContext {
		public IToken alias;
		[System.Diagnostics.DebuggerNonUserCode] public ImportPathContext importPath() {
			return GetRuleContext<ImportPathContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public ImportSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterImportSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitImportSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportSpecContext importSpec() {
		ImportSpecContext _localctx = new ImportSpecContext(Context, State);
		EnterRule(_localctx, 6, RULE_importSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 248;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IDENTIFIER || _la==DOT) {
				{
				State = 247;
				_localctx.alias = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==IDENTIFIER || _la==DOT) ) {
					_localctx.alias = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 250;
			importPath();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportPathContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public String_Context string_() {
			return GetRuleContext<String_Context>(0);
		}
		public ImportPathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importPath; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterImportPath(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitImportPath(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportPath(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportPathContext importPath() {
		ImportPathContext _localctx = new ImportPathContext(Context, State);
		EnterRule(_localctx, 8, RULE_importPath);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 252;
			string_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstDeclContext constDecl() {
			return GetRuleContext<ConstDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDeclContext typeDecl() {
			return GetRuleContext<TypeDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarDeclContext varDecl() {
			return GetRuleContext<VarDeclContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 10, RULE_declaration);
		try {
			State = 257;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 254;
				constDecl();
				}
				break;
			case TYPE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 255;
				typeDecl();
				}
				break;
			case VAR:
				EnterOuterAlt(_localctx, 3);
				{
				State = 256;
				varDecl();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONST() { return GetToken(GoParser.CONST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstSpecContext[] constSpec() {
			return GetRuleContexts<ConstSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstSpecContext constSpec(int i) {
			return GetRuleContext<ConstSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ConstDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterConstDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitConstDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstDeclContext constDecl() {
		ConstDeclContext _localctx = new ConstDeclContext(Context, State);
		EnterRule(_localctx, 12, RULE_constDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259;
			Match(CONST);
			State = 271;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				{
				State = 260;
				constSpec();
				}
				break;
			case L_PAREN:
				{
				State = 261;
				Match(L_PAREN);
				State = 267;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==IDENTIFIER) {
					{
					{
					State = 262;
					constSpec();
					State = 263;
					eos();
					}
					}
					State = 269;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 270;
				Match(R_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ConstSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterConstSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitConstSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstSpecContext constSpec() {
		ConstSpecContext _localctx = new ConstSpecContext(Context, State);
		EnterRule(_localctx, 14, RULE_constSpec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 273;
			identifierList();
			State = 279;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				{
				State = 275;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 3)) & ~0x3f) == 0 && ((1L << (_la - 3)) & 2882303762104320451L) != 0)) {
					{
					State = 274;
					type_();
					}
				}

				State = 277;
				Match(ASSIGN);
				State = 278;
				expressionList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IDENTIFIER() { return GetTokens(GoParser.IDENTIFIER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GoParser.IDENTIFIER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		IdentifierListContext _localctx = new IdentifierListContext(Context, State);
		EnterRule(_localctx, 16, RULE_identifierList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 281;
			Match(IDENTIFIER);
			State = 286;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 282;
					Match(COMMA);
					State = 283;
					Match(IDENTIFIER);
					}
					} 
				}
				State = 288;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 18, RULE_expressionList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 289;
			expression(0);
			State = 294;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 290;
					Match(COMMA);
					State = 291;
					expression(0);
					}
					} 
				}
				State = 296;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(GoParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecContext[] typeSpec() {
			return GetRuleContexts<TypeSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSpecContext typeSpec(int i) {
			return GetRuleContext<TypeSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public TypeDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeDeclContext typeDecl() {
		TypeDeclContext _localctx = new TypeDeclContext(Context, State);
		EnterRule(_localctx, 20, RULE_typeDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 297;
			Match(TYPE);
			State = 309;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				{
				State = 298;
				typeSpec();
				}
				break;
			case L_PAREN:
				{
				State = 299;
				Match(L_PAREN);
				State = 305;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==IDENTIFIER) {
					{
					{
					State = 300;
					typeSpec();
					State = 301;
					eos();
					}
					}
					State = 307;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 308;
				Match(R_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AliasDeclContext aliasDecl() {
			return GetRuleContext<AliasDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeDefContext typeDef() {
			return GetRuleContext<TypeDefContext>(0);
		}
		public TypeSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSpecContext typeSpec() {
		TypeSpecContext _localctx = new TypeSpecContext(Context, State);
		EnterRule(_localctx, 22, RULE_typeSpec);
		try {
			State = 313;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 311;
				aliasDecl();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 312;
				typeDef();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public AliasDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterAliasDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitAliasDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasDeclContext aliasDecl() {
		AliasDeclContext _localctx = new AliasDeclContext(Context, State);
		EnterRule(_localctx, 24, RULE_aliasDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 315;
			Match(IDENTIFIER);
			State = 316;
			Match(ASSIGN);
			State = 317;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParametersContext typeParameters() {
			return GetRuleContext<TypeParametersContext>(0);
		}
		public TypeDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeDefContext typeDef() {
		TypeDefContext _localctx = new TypeDefContext(Context, State);
		EnterRule(_localctx, 26, RULE_typeDef);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 319;
			Match(IDENTIFIER);
			State = 321;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 320;
				typeParameters();
				}
				break;
			}
			State = 323;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeParameterDeclContext[] typeParameterDecl() {
			return GetRuleContexts<TypeParameterDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParameterDeclContext typeParameterDecl(int i) {
			return GetRuleContext<TypeParameterDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public TypeParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeParametersContext typeParameters() {
		TypeParametersContext _localctx = new TypeParametersContext(Context, State);
		EnterRule(_localctx, 28, RULE_typeParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 325;
			Match(L_BRACKET);
			State = 326;
			typeParameterDecl();
			State = 331;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 327;
				Match(COMMA);
				State = 328;
				typeParameterDecl();
				}
				}
				State = 333;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 334;
			Match(R_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeParameterDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeElementContext typeElement() {
			return GetRuleContext<TypeElementContext>(0);
		}
		public TypeParameterDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeParameterDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeParameterDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeParameterDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeParameterDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeParameterDeclContext typeParameterDecl() {
		TypeParameterDeclContext _localctx = new TypeParameterDeclContext(Context, State);
		EnterRule(_localctx, 30, RULE_typeParameterDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 336;
			identifierList();
			State = 337;
			typeElement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeTermContext[] typeTerm() {
			return GetRuleContexts<TypeTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeTermContext typeTerm(int i) {
			return GetRuleContext<TypeTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(GoParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(GoParser.OR, i);
		}
		public TypeElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeElementContext typeElement() {
		TypeElementContext _localctx = new TypeElementContext(Context, State);
		EnterRule(_localctx, 32, RULE_typeElement);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 339;
			typeTerm();
			State = 344;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 340;
					Match(OR);
					State = 341;
					typeTerm();
					}
					} 
				}
				State = 346;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,18,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeTermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNDERLYING() { return GetToken(GoParser.UNDERLYING, 0); }
		public TypeTermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeTerm; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeTermContext typeTerm() {
		TypeTermContext _localctx = new TypeTermContext(Context, State);
		EnterRule(_localctx, 34, RULE_typeTerm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 348;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==UNDERLYING) {
				{
				State = 347;
				Match(UNDERLYING);
				}
			}

			State = 350;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNC() { return GetToken(GoParser.FUNC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignatureContext signature() {
			return GetRuleContext<SignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeParametersContext typeParameters() {
			return GetRuleContext<TypeParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public FunctionDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterFunctionDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitFunctionDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDeclContext functionDecl() {
		FunctionDeclContext _localctx = new FunctionDeclContext(Context, State);
		EnterRule(_localctx, 36, RULE_functionDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 352;
			Match(FUNC);
			State = 353;
			Match(IDENTIFIER);
			State = 355;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==L_BRACKET) {
				{
				State = 354;
				typeParameters();
				}
			}

			State = 357;
			signature();
			State = 359;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				{
				State = 358;
				block();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNC() { return GetToken(GoParser.FUNC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReceiverContext receiver() {
			return GetRuleContext<ReceiverContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignatureContext signature() {
			return GetRuleContext<SignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public MethodDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterMethodDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitMethodDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodDeclContext methodDecl() {
		MethodDeclContext _localctx = new MethodDeclContext(Context, State);
		EnterRule(_localctx, 38, RULE_methodDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 361;
			Match(FUNC);
			State = 362;
			receiver();
			State = 363;
			Match(IDENTIFIER);
			State = 364;
			signature();
			State = 366;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 365;
				block();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReceiverContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ReceiverContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_receiver; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterReceiver(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitReceiver(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReceiver(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReceiverContext receiver() {
		ReceiverContext _localctx = new ReceiverContext(Context, State);
		EnterRule(_localctx, 40, RULE_receiver);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 368;
			parameters();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VAR() { return GetToken(GoParser.VAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VarSpecContext[] varSpec() {
			return GetRuleContexts<VarSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarSpecContext varSpec(int i) {
			return GetRuleContext<VarSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public VarDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterVarDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitVarDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarDeclContext varDecl() {
		VarDeclContext _localctx = new VarDeclContext(Context, State);
		EnterRule(_localctx, 42, RULE_varDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 370;
			Match(VAR);
			State = 382;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				{
				State = 371;
				varSpec();
				}
				break;
			case L_PAREN:
				{
				State = 372;
				Match(L_PAREN);
				State = 378;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==IDENTIFIER) {
					{
					{
					State = 373;
					varSpec();
					State = 374;
					eos();
					}
					}
					State = 380;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 381;
				Match(R_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public VarSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterVarSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitVarSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarSpecContext varSpec() {
		VarSpecContext _localctx = new VarSpecContext(Context, State);
		EnterRule(_localctx, 44, RULE_varSpec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 384;
			identifierList();
			State = 392;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FUNC:
			case INTERFACE:
			case MAP:
			case STRUCT:
			case CHAN:
			case IDENTIFIER:
			case L_PAREN:
			case L_BRACKET:
			case STAR:
			case RECEIVE:
				{
				State = 385;
				type_();
				State = 388;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
				case 1:
					{
					State = 386;
					Match(ASSIGN);
					State = 387;
					expressionList();
					}
					break;
				}
				}
				break;
			case ASSIGN:
				{
				State = 390;
				Match(ASSIGN);
				State = 391;
				expressionList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 46, RULE_block);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 394;
			Match(L_CURLY);
			State = 396;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				{
				State = 395;
				statementList();
				}
				break;
			}
			State = 398;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMI() { return GetTokens(GoParser.SEMI); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI(int i) {
			return GetToken(GoParser.SEMI, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] EOS() { return GetTokens(GoParser.EOS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EOS(int i) {
			return GetToken(GoParser.EOS, i);
		}
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitStatementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		StatementListContext _localctx = new StatementListContext(Context, State);
		EnterRule(_localctx, 48, RULE_statementList);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 412;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 407;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
					case 1:
						{
						State = 401;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==SEMI) {
							{
							State = 400;
							Match(SEMI);
							}
						}

						}
						break;
					case 2:
						{
						State = 404;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==EOS) {
							{
							State = 403;
							Match(EOS);
							}
						}

						}
						break;
					case 3:
						{
						State = 406;
						if (!(this.closingBracket())) throw new FailedPredicateException(this, "this.closingBracket()");
						}
						break;
					}
					State = 409;
					statement();
					State = 410;
					eos();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 414;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabeledStmtContext labeledStmt() {
			return GetRuleContext<LabeledStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext simpleStmt() {
			return GetRuleContext<SimpleStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GoStmtContext goStmt() {
			return GetRuleContext<GoStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStmtContext returnStmt() {
			return GetRuleContext<ReturnStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BreakStmtContext breakStmt() {
			return GetRuleContext<BreakStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ContinueStmtContext continueStmt() {
			return GetRuleContext<ContinueStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GotoStmtContext gotoStmt() {
			return GetRuleContext<GotoStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FallthroughStmtContext fallthroughStmt() {
			return GetRuleContext<FallthroughStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SwitchStmtContext switchStmt() {
			return GetRuleContext<SwitchStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SelectStmtContext selectStmt() {
			return GetRuleContext<SelectStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForStmtContext forStmt() {
			return GetRuleContext<ForStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferStmtContext deferStmt() {
			return GetRuleContext<DeferStmtContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 50, RULE_statement);
		try {
			State = 431;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 416;
				declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 417;
				labeledStmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 418;
				simpleStmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 419;
				goStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 420;
				returnStmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 421;
				breakStmt();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 422;
				continueStmt();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 423;
				gotoStmt();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 424;
				fallthroughStmt();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 425;
				block();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 426;
				ifStmt();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 427;
				switchStmt();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 428;
				selectStmt();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 429;
				forStmt();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 430;
				deferStmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SendStmtContext sendStmt() {
			return GetRuleContext<SendStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IncDecStmtContext incDecStmt() {
			return GetRuleContext<IncDecStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStmtContext expressionStmt() {
			return GetRuleContext<ExpressionStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShortVarDeclContext shortVarDecl() {
			return GetRuleContext<ShortVarDeclContext>(0);
		}
		public SimpleStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSimpleStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSimpleStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleStmtContext simpleStmt() {
		SimpleStmtContext _localctx = new SimpleStmtContext(Context, State);
		EnterRule(_localctx, 52, RULE_simpleStmt);
		try {
			State = 438;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 433;
				sendStmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 434;
				incDecStmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 435;
				assignment();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 436;
				expressionStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 437;
				shortVarDecl();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpressionStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExpressionStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExpressionStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStmtContext expressionStmt() {
		ExpressionStmtContext _localctx = new ExpressionStmtContext(Context, State);
		EnterRule(_localctx, 54, RULE_expressionStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 440;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SendStmtContext : ParserRuleContext {
		public ExpressionContext channel;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECEIVE() { return GetToken(GoParser.RECEIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public SendStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sendStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSendStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSendStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSendStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SendStmtContext sendStmt() {
		SendStmtContext _localctx = new SendStmtContext(Context, State);
		EnterRule(_localctx, 56, RULE_sendStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 442;
			_localctx.channel = expression(0);
			State = 443;
			Match(RECEIVE);
			State = 444;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncDecStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_PLUS() { return GetToken(GoParser.PLUS_PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_MINUS() { return GetToken(GoParser.MINUS_MINUS, 0); }
		public IncDecStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_incDecStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterIncDecStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitIncDecStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIncDecStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncDecStmtContext incDecStmt() {
		IncDecStmtContext _localctx = new IncDecStmtContext(Context, State);
		EnterRule(_localctx, 58, RULE_incDecStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 446;
			expression(0);
			State = 447;
			_la = TokenStream.LA(1);
			if ( !(_la==PLUS_PLUS || _la==MINUS_MINUS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext[] expressionList() {
			return GetRuleContexts<ExpressionListContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList(int i) {
			return GetRuleContext<ExpressionListContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Assign_opContext assign_op() {
			return GetRuleContext<Assign_opContext>(0);
		}
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(Context, State);
		EnterRule(_localctx, 60, RULE_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 449;
			expressionList();
			State = 450;
			assign_op();
			State = 451;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assign_opContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(GoParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(GoParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(GoParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CARET() { return GetToken(GoParser.CARET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(GoParser.STAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(GoParser.DIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(GoParser.MOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSHIFT() { return GetToken(GoParser.LSHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSHIFT() { return GetToken(GoParser.RSHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND() { return GetToken(GoParser.AMPERSAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BIT_CLEAR() { return GetToken(GoParser.BIT_CLEAR, 0); }
		public Assign_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign_op; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterAssign_op(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitAssign_op(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assign_opContext assign_op() {
		Assign_opContext _localctx = new Assign_opContext(Context, State);
		EnterRule(_localctx, 62, RULE_assign_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 454;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -434597364041252864L) != 0)) {
				{
				State = 453;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & -434597364041252864L) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 456;
			Match(ASSIGN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortVarDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE_ASSIGN() { return GetToken(GoParser.DECLARE_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ShortVarDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortVarDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterShortVarDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitShortVarDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortVarDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortVarDeclContext shortVarDecl() {
		ShortVarDeclContext _localctx = new ShortVarDeclContext(Context, State);
		EnterRule(_localctx, 64, RULE_shortVarDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 458;
			identifierList();
			State = 459;
			Match(DECLARE_ASSIGN);
			State = 460;
			expressionList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabeledStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(GoParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public LabeledStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labeledStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterLabeledStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitLabeledStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabeledStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabeledStmtContext labeledStmt() {
		LabeledStmtContext _localctx = new LabeledStmtContext(Context, State);
		EnterRule(_localctx, 66, RULE_labeledStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 462;
			Match(IDENTIFIER);
			State = 463;
			Match(COLON);
			State = 465;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				{
				State = 464;
				statement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(GoParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ReturnStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStmtContext returnStmt() {
		ReturnStmtContext _localctx = new ReturnStmtContext(Context, State);
		EnterRule(_localctx, 68, RULE_returnStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 467;
			Match(RETURN);
			State = 469;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
			case 1:
				{
				State = 468;
				expressionList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BreakStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(GoParser.BREAK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public BreakStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_breakStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterBreakStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitBreakStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBreakStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BreakStmtContext breakStmt() {
		BreakStmtContext _localctx = new BreakStmtContext(Context, State);
		EnterRule(_localctx, 70, RULE_breakStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 471;
			Match(BREAK);
			State = 473;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,37,Context) ) {
			case 1:
				{
				State = 472;
				Match(IDENTIFIER);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContinueStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(GoParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public ContinueStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continueStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterContinueStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitContinueStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinueStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContinueStmtContext continueStmt() {
		ContinueStmtContext _localctx = new ContinueStmtContext(Context, State);
		EnterRule(_localctx, 72, RULE_continueStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 475;
			Match(CONTINUE);
			State = 477;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
			case 1:
				{
				State = 476;
				Match(IDENTIFIER);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GotoStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GOTO() { return GetToken(GoParser.GOTO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public GotoStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_gotoStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterGotoStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitGotoStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGotoStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GotoStmtContext gotoStmt() {
		GotoStmtContext _localctx = new GotoStmtContext(Context, State);
		EnterRule(_localctx, 74, RULE_gotoStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 479;
			Match(GOTO);
			State = 480;
			Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FallthroughStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALLTHROUGH() { return GetToken(GoParser.FALLTHROUGH, 0); }
		public FallthroughStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fallthroughStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterFallthroughStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitFallthroughStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFallthroughStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FallthroughStmtContext fallthroughStmt() {
		FallthroughStmtContext _localctx = new FallthroughStmtContext(Context, State);
		EnterRule(_localctx, 76, RULE_fallthroughStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 482;
			Match(FALLTHROUGH);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFER() { return GetToken(GoParser.DEFER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public DeferStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeferStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeferStmtContext deferStmt() {
		DeferStmtContext _localctx = new DeferStmtContext(Context, State);
		EnterRule(_localctx, 78, RULE_deferStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 484;
			Match(DEFER);
			State = 485;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(GoParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext simpleStmt() {
			return GetRuleContext<SimpleStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(GoParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		public IfStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStmtContext ifStmt() {
		IfStmtContext _localctx = new IfStmtContext(Context, State);
		EnterRule(_localctx, 80, RULE_ifStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 487;
			Match(IF);
			State = 496;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 488;
				expression(0);
				}
				break;
			case 2:
				{
				State = 489;
				eos();
				State = 490;
				expression(0);
				}
				break;
			case 3:
				{
				State = 492;
				simpleStmt();
				State = 493;
				eos();
				State = 494;
				expression(0);
				}
				break;
			}
			State = 498;
			block();
			State = 504;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				{
				State = 499;
				Match(ELSE);
				State = 502;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IF:
					{
					State = 500;
					ifStmt();
					}
					break;
				case L_CURLY:
					{
					State = 501;
					block();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprSwitchStmtContext exprSwitchStmt() {
			return GetRuleContext<ExprSwitchStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeSwitchStmtContext typeSwitchStmt() {
			return GetRuleContext<TypeSwitchStmtContext>(0);
		}
		public SwitchStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchStmtContext switchStmt() {
		SwitchStmtContext _localctx = new SwitchStmtContext(Context, State);
		EnterRule(_localctx, 82, RULE_switchStmt);
		try {
			State = 508;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,42,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 506;
				exprSwitchStmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 507;
				typeSwitchStmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprSwitchStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SWITCH() { return GetToken(GoParser.SWITCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprCaseClauseContext[] exprCaseClause() {
			return GetRuleContexts<ExprCaseClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprCaseClauseContext exprCaseClause(int i) {
			return GetRuleContext<ExprCaseClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext simpleStmt() {
			return GetRuleContext<SimpleStmtContext>(0);
		}
		public ExprSwitchStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprSwitchStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExprSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExprSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprSwitchStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprSwitchStmtContext exprSwitchStmt() {
		ExprSwitchStmtContext _localctx = new ExprSwitchStmtContext(Context, State);
		EnterRule(_localctx, 84, RULE_exprSwitchStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 510;
			Match(SWITCH);
			State = 521;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				{
				State = 512;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 511;
					expression(0);
					}
				}

				}
				break;
			case 2:
				{
				State = 515;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,44,Context) ) {
				case 1:
					{
					State = 514;
					simpleStmt();
					}
					break;
				}
				State = 517;
				eos();
				State = 519;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 518;
					expression(0);
					}
				}

				}
				break;
			}
			State = 523;
			Match(L_CURLY);
			State = 527;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT || _la==CASE) {
				{
				{
				State = 524;
				exprCaseClause();
				}
				}
				State = 529;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 530;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprCaseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprSwitchCaseContext exprSwitchCase() {
			return GetRuleContext<ExprSwitchCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(GoParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public ExprCaseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprCaseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExprCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExprCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprCaseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprCaseClauseContext exprCaseClause() {
		ExprCaseClauseContext _localctx = new ExprCaseClauseContext(Context, State);
		EnterRule(_localctx, 86, RULE_exprCaseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 532;
			exprSwitchCase();
			State = 533;
			Match(COLON);
			State = 535;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				{
				State = 534;
				statementList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprSwitchCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(GoParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(GoParser.DEFAULT, 0); }
		public ExprSwitchCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprSwitchCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExprSwitchCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExprSwitchCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprSwitchCase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprSwitchCaseContext exprSwitchCase() {
		ExprSwitchCaseContext _localctx = new ExprSwitchCaseContext(Context, State);
		EnterRule(_localctx, 88, RULE_exprSwitchCase);
		try {
			State = 540;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 537;
				Match(CASE);
				State = 538;
				expressionList();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 539;
				Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSwitchStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SWITCH() { return GetToken(GoParser.SWITCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeSwitchGuardContext typeSwitchGuard() {
			return GetRuleContext<TypeSwitchGuardContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext simpleStmt() {
			return GetRuleContext<SimpleStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeCaseClauseContext[] typeCaseClause() {
			return GetRuleContexts<TypeCaseClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeCaseClauseContext typeCaseClause(int i) {
			return GetRuleContext<TypeCaseClauseContext>(i);
		}
		public TypeSwitchStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSwitchStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeSwitchStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSwitchStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSwitchStmtContext typeSwitchStmt() {
		TypeSwitchStmtContext _localctx = new TypeSwitchStmtContext(Context, State);
		EnterRule(_localctx, 90, RULE_typeSwitchStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 542;
			Match(SWITCH);
			State = 551;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
			case 1:
				{
				State = 543;
				typeSwitchGuard();
				}
				break;
			case 2:
				{
				State = 544;
				eos();
				State = 545;
				typeSwitchGuard();
				}
				break;
			case 3:
				{
				State = 547;
				simpleStmt();
				State = 548;
				eos();
				State = 549;
				typeSwitchGuard();
				}
				break;
			}
			State = 553;
			Match(L_CURLY);
			State = 557;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT || _la==CASE) {
				{
				{
				State = 554;
				typeCaseClause();
				}
				}
				State = 559;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 560;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSwitchGuardContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExprContext primaryExpr() {
			return GetRuleContext<PrimaryExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(GoParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE_ASSIGN() { return GetToken(GoParser.DECLARE_ASSIGN, 0); }
		public TypeSwitchGuardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSwitchGuard; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeSwitchGuard(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeSwitchGuard(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSwitchGuard(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSwitchGuardContext typeSwitchGuard() {
		TypeSwitchGuardContext _localctx = new TypeSwitchGuardContext(Context, State);
		EnterRule(_localctx, 92, RULE_typeSwitchGuard);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 564;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,52,Context) ) {
			case 1:
				{
				State = 562;
				Match(IDENTIFIER);
				State = 563;
				Match(DECLARE_ASSIGN);
				}
				break;
			}
			State = 566;
			primaryExpr(0);
			State = 567;
			Match(DOT);
			State = 568;
			Match(L_PAREN);
			State = 569;
			Match(TYPE);
			State = 570;
			Match(R_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeCaseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeSwitchCaseContext typeSwitchCase() {
			return GetRuleContext<TypeSwitchCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(GoParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public TypeCaseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeCaseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeCaseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeCaseClauseContext typeCaseClause() {
		TypeCaseClauseContext _localctx = new TypeCaseClauseContext(Context, State);
		EnterRule(_localctx, 94, RULE_typeCaseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 572;
			typeSwitchCase();
			State = 573;
			Match(COLON);
			State = 575;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,53,Context) ) {
			case 1:
				{
				State = 574;
				statementList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeSwitchCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(GoParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeListContext typeList() {
			return GetRuleContext<TypeListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(GoParser.DEFAULT, 0); }
		public TypeSwitchCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeSwitchCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeSwitchCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeSwitchCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeSwitchCase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeSwitchCaseContext typeSwitchCase() {
		TypeSwitchCaseContext _localctx = new TypeSwitchCaseContext(Context, State);
		EnterRule(_localctx, 96, RULE_typeSwitchCase);
		try {
			State = 580;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 577;
				Match(CASE);
				State = 578;
				typeList();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 579;
				Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context[] type_() {
			return GetRuleContexts<Type_Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_(int i) {
			return GetRuleContext<Type_Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NIL_LIT() { return GetTokens(GoParser.NIL_LIT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NIL_LIT(int i) {
			return GetToken(GoParser.NIL_LIT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public TypeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeListContext typeList() {
		TypeListContext _localctx = new TypeListContext(Context, State);
		EnterRule(_localctx, 98, RULE_typeList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 584;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FUNC:
			case INTERFACE:
			case MAP:
			case STRUCT:
			case CHAN:
			case IDENTIFIER:
			case L_PAREN:
			case L_BRACKET:
			case STAR:
			case RECEIVE:
				{
				State = 582;
				type_();
				}
				break;
			case NIL_LIT:
				{
				State = 583;
				Match(NIL_LIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 593;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,57,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 586;
					Match(COMMA);
					State = 589;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case FUNC:
					case INTERFACE:
					case MAP:
					case STRUCT:
					case CHAN:
					case IDENTIFIER:
					case L_PAREN:
					case L_BRACKET:
					case STAR:
					case RECEIVE:
						{
						State = 587;
						type_();
						}
						break;
					case NIL_LIT:
						{
						State = 588;
						Match(NIL_LIT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				State = 595;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,57,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SELECT() { return GetToken(GoParser.SELECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommClauseContext[] commClause() {
			return GetRuleContexts<CommClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommClauseContext commClause(int i) {
			return GetRuleContext<CommClauseContext>(i);
		}
		public SelectStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selectStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSelectStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSelectStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelectStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectStmtContext selectStmt() {
		SelectStmtContext _localctx = new SelectStmtContext(Context, State);
		EnterRule(_localctx, 100, RULE_selectStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 596;
			Match(SELECT);
			State = 597;
			Match(L_CURLY);
			State = 601;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DEFAULT || _la==CASE) {
				{
				{
				State = 598;
				commClause();
				}
				}
				State = 603;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 604;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CommCaseContext commCase() {
			return GetRuleContext<CommCaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(GoParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public CommClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterCommClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitCommClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommClauseContext commClause() {
		CommClauseContext _localctx = new CommClauseContext(Context, State);
		EnterRule(_localctx, 102, RULE_commClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 606;
			commCase();
			State = 607;
			Match(COLON);
			State = 609;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
			case 1:
				{
				State = 608;
				statementList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(GoParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SendStmtContext sendStmt() {
			return GetRuleContext<SendStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RecvStmtContext recvStmt() {
			return GetRuleContext<RecvStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(GoParser.DEFAULT, 0); }
		public CommCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterCommCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitCommCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommCase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommCaseContext commCase() {
		CommCaseContext _localctx = new CommCaseContext(Context, State);
		EnterRule(_localctx, 104, RULE_commCase);
		try {
			State = 617;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CASE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 611;
				Match(CASE);
				State = 614;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
				case 1:
					{
					State = 612;
					sendStmt();
					}
					break;
				case 2:
					{
					State = 613;
					recvStmt();
					}
					break;
				}
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 616;
				Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RecvStmtContext : ParserRuleContext {
		public ExpressionContext recvExpr;
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE_ASSIGN() { return GetToken(GoParser.DECLARE_ASSIGN, 0); }
		public RecvStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_recvStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterRecvStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitRecvStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecvStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RecvStmtContext recvStmt() {
		RecvStmtContext _localctx = new RecvStmtContext(Context, State);
		EnterRule(_localctx, 106, RULE_recvStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 625;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				{
				State = 619;
				expressionList();
				State = 620;
				Match(ASSIGN);
				}
				break;
			case 2:
				{
				State = 622;
				identifierList();
				State = 623;
				Match(DECLARE_ASSIGN);
				}
				break;
			}
			State = 627;
			_localctx.recvExpr = expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(GoParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForClauseContext forClause() {
			return GetRuleContext<ForClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RangeClauseContext rangeClause() {
			return GetRuleContext<RangeClauseContext>(0);
		}
		public ForStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterForStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitForStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForStmtContext forStmt() {
		ForStmtContext _localctx = new ForStmtContext(Context, State);
		EnterRule(_localctx, 108, RULE_forStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 629;
			Match(FOR);
			State = 637;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
			case 1:
				{
				State = 631;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 630;
					expression(0);
					}
				}

				}
				break;
			case 2:
				{
				State = 633;
				forClause();
				}
				break;
			case 3:
				{
				State = 635;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386454504L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 634;
					rangeClause();
					}
				}

				}
				break;
			}
			State = 639;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForClauseContext : ParserRuleContext {
		public SimpleStmtContext initStmt;
		public SimpleStmtContext postStmt;
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext[] simpleStmt() {
			return GetRuleContexts<SimpleStmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleStmtContext simpleStmt(int i) {
			return GetRuleContext<SimpleStmtContext>(i);
		}
		public ForClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitForClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForClauseContext forClause() {
		ForClauseContext _localctx = new ForClauseContext(Context, State);
		EnterRule(_localctx, 110, RULE_forClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 642;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
			case 1:
				{
				State = 641;
				_localctx.initStmt = simpleStmt();
				}
				break;
			}
			State = 644;
			eos();
			State = 646;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
			case 1:
				{
				State = 645;
				expression(0);
				}
				break;
			}
			State = 648;
			eos();
			State = 650;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
				{
				State = 649;
				_localctx.postStmt = simpleStmt();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RangeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(GoParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(GoParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECLARE_ASSIGN() { return GetToken(GoParser.DECLARE_ASSIGN, 0); }
		public RangeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rangeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterRangeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitRangeClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRangeClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RangeClauseContext rangeClause() {
		RangeClauseContext _localctx = new RangeClauseContext(Context, State);
		EnterRule(_localctx, 112, RULE_rangeClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 658;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,69,Context) ) {
			case 1:
				{
				State = 652;
				expressionList();
				State = 653;
				Match(ASSIGN);
				}
				break;
			case 2:
				{
				State = 655;
				identifierList();
				State = 656;
				Match(DECLARE_ASSIGN);
				}
				break;
			}
			State = 660;
			Match(RANGE);
			State = 661;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GoStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GO() { return GetToken(GoParser.GO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public GoStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_goStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterGoStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitGoStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGoStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GoStmtContext goStmt() {
		GoStmtContext _localctx = new GoStmtContext(Context, State);
		EnterRule(_localctx, 114, RULE_goStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 663;
			Match(GO);
			State = 664;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgsContext typeArgs() {
			return GetRuleContext<TypeArgsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeLitContext typeLit() {
			return GetRuleContext<TypeLitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		public Type_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterType_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitType_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_Context type_() {
		Type_Context _localctx = new Type_Context(Context, State);
		EnterRule(_localctx, 116, RULE_type_);
		try {
			State = 675;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 666;
				typeName();
				State = 668;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
				case 1:
					{
					State = 667;
					typeArgs();
					}
					break;
				}
				}
				break;
			case FUNC:
			case INTERFACE:
			case MAP:
			case STRUCT:
			case CHAN:
			case L_BRACKET:
			case STAR:
			case RECEIVE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 670;
				typeLit();
				}
				break;
			case L_PAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 671;
				Match(L_PAREN);
				State = 672;
				type_();
				State = 673;
				Match(R_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeArgsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeListContext typeList() {
			return GetRuleContext<TypeListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(GoParser.COMMA, 0); }
		public TypeArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeArgs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeArgsContext typeArgs() {
		TypeArgsContext _localctx = new TypeArgsContext(Context, State);
		EnterRule(_localctx, 118, RULE_typeArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 677;
			Match(L_BRACKET);
			State = 678;
			typeList();
			State = 680;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 679;
				Match(COMMA);
				}
			}

			State = 682;
			Match(R_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public QualifiedIdentContext qualifiedIdent() {
			return GetRuleContext<QualifiedIdentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 120, RULE_typeName);
		try {
			State = 686;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 684;
				qualifiedIdent();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 685;
				Match(IDENTIFIER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeLitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayTypeContext arrayType() {
			return GetRuleContext<ArrayTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructTypeContext structType() {
			return GetRuleContext<StructTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PointerTypeContext pointerType() {
			return GetRuleContext<PointerTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionTypeContext functionType() {
			return GetRuleContext<FunctionTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InterfaceTypeContext interfaceType() {
			return GetRuleContext<InterfaceTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SliceTypeContext sliceType() {
			return GetRuleContext<SliceTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapTypeContext mapType() {
			return GetRuleContext<MapTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ChannelTypeContext channelType() {
			return GetRuleContext<ChannelTypeContext>(0);
		}
		public TypeLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeLit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeLitContext typeLit() {
		TypeLitContext _localctx = new TypeLitContext(Context, State);
		EnterRule(_localctx, 122, RULE_typeLit);
		try {
			State = 696;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 688;
				arrayType();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 689;
				structType();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 690;
				pointerType();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 691;
				functionType();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 692;
				interfaceType();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 693;
				sliceType();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 694;
				mapType();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 695;
				channelType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArrayLengthContext arrayLength() {
			return GetRuleContext<ArrayLengthContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementTypeContext elementType() {
			return GetRuleContext<ElementTypeContext>(0);
		}
		public ArrayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterArrayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitArrayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayTypeContext arrayType() {
		ArrayTypeContext _localctx = new ArrayTypeContext(Context, State);
		EnterRule(_localctx, 124, RULE_arrayType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 698;
			Match(L_BRACKET);
			State = 699;
			arrayLength();
			State = 700;
			Match(R_BRACKET);
			State = 701;
			elementType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayLengthContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArrayLengthContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayLength; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterArrayLength(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitArrayLength(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayLength(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayLengthContext arrayLength() {
		ArrayLengthContext _localctx = new ArrayLengthContext(Context, State);
		EnterRule(_localctx, 126, RULE_arrayLength);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 703;
			expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ElementTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterElementType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitElementType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementTypeContext elementType() {
		ElementTypeContext _localctx = new ElementTypeContext(Context, State);
		EnterRule(_localctx, 128, RULE_elementType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 705;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PointerTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(GoParser.STAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public PointerTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointerType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterPointerType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitPointerType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointerType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerTypeContext pointerType() {
		PointerTypeContext _localctx = new PointerTypeContext(Context, State);
		EnterRule(_localctx, 130, RULE_pointerType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 707;
			Match(STAR);
			State = 708;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterfaceTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(GoParser.INTERFACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MethodSpecContext[] methodSpec() {
			return GetRuleContexts<MethodSpecContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MethodSpecContext methodSpec(int i) {
			return GetRuleContext<MethodSpecContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeElementContext[] typeElement() {
			return GetRuleContexts<TypeElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeElementContext typeElement(int i) {
			return GetRuleContext<TypeElementContext>(i);
		}
		public InterfaceTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interfaceType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterInterfaceType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitInterfaceType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterfaceType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InterfaceTypeContext interfaceType() {
		InterfaceTypeContext _localctx = new InterfaceTypeContext(Context, State);
		EnterRule(_localctx, 132, RULE_interfaceType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 710;
			Match(INTERFACE);
			State = 711;
			Match(L_CURLY);
			State = 720;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 3)) & ~0x3f) == 0 && ((1L << (_la - 3)) & 2900318160613802435L) != 0)) {
				{
				{
				State = 714;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
				case 1:
					{
					State = 712;
					methodSpec();
					}
					break;
				case 2:
					{
					State = 713;
					typeElement();
					}
					break;
				}
				State = 716;
				eos();
				}
				}
				State = 722;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 723;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SliceTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementTypeContext elementType() {
			return GetRuleContext<ElementTypeContext>(0);
		}
		public SliceTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sliceType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSliceType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSliceType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSliceType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SliceTypeContext sliceType() {
		SliceTypeContext _localctx = new SliceTypeContext(Context, State);
		EnterRule(_localctx, 134, RULE_sliceType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 725;
			Match(L_BRACKET);
			State = 726;
			Match(R_BRACKET);
			State = 727;
			elementType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(GoParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementTypeContext elementType() {
			return GetRuleContext<ElementTypeContext>(0);
		}
		public MapTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterMapType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitMapType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapTypeContext mapType() {
		MapTypeContext _localctx = new MapTypeContext(Context, State);
		EnterRule(_localctx, 136, RULE_mapType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 729;
			Match(MAP);
			State = 730;
			Match(L_BRACKET);
			State = 731;
			type_();
			State = 732;
			Match(R_BRACKET);
			State = 733;
			elementType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ChannelTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementTypeContext elementType() {
			return GetRuleContext<ElementTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAN() { return GetToken(GoParser.CHAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECEIVE() { return GetToken(GoParser.RECEIVE, 0); }
		public ChannelTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_channelType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterChannelType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitChannelType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChannelType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ChannelTypeContext channelType() {
		ChannelTypeContext _localctx = new ChannelTypeContext(Context, State);
		EnterRule(_localctx, 138, RULE_channelType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 740;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,77,Context) ) {
			case 1:
				{
				State = 735;
				Match(CHAN);
				}
				break;
			case 2:
				{
				State = 736;
				Match(CHAN);
				State = 737;
				Match(RECEIVE);
				}
				break;
			case 3:
				{
				State = 738;
				Match(RECEIVE);
				State = 739;
				Match(CHAN);
				}
				break;
			}
			State = 742;
			elementType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodSpecContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultContext result() {
			return GetRuleContext<ResultContext>(0);
		}
		public MethodSpecContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodSpec; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterMethodSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitMethodSpec(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodSpec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodSpecContext methodSpec() {
		MethodSpecContext _localctx = new MethodSpecContext(Context, State);
		EnterRule(_localctx, 140, RULE_methodSpec);
		try {
			State = 750;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,78,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 744;
				Match(IDENTIFIER);
				State = 745;
				parameters();
				State = 746;
				result();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 748;
				Match(IDENTIFIER);
				State = 749;
				parameters();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNC() { return GetToken(GoParser.FUNC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignatureContext signature() {
			return GetRuleContext<SignatureContext>(0);
		}
		public FunctionTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterFunctionType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitFunctionType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionTypeContext functionType() {
		FunctionTypeContext _localctx = new FunctionTypeContext(Context, State);
		EnterRule(_localctx, 142, RULE_functionType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 752;
			Match(FUNC);
			State = 753;
			signature();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignatureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ResultContext result() {
			return GetRuleContext<ResultContext>(0);
		}
		public SignatureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signature; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSignature(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSignature(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignatureContext signature() {
		SignatureContext _localctx = new SignatureContext(Context, State);
		EnterRule(_localctx, 144, RULE_signature);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 755;
			parameters();
			State = 757;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,79,Context) ) {
			case 1:
				{
				State = 756;
				result();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		public ResultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterResult(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitResult(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResult(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResultContext result() {
		ResultContext _localctx = new ResultContext(Context, State);
		EnterRule(_localctx, 146, RULE_result);
		try {
			State = 761;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,80,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 759;
				parameters();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 760;
				type_();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterDeclContext[] parameterDecl() {
			return GetRuleContexts<ParameterDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterDeclContext parameterDecl(int i) {
			return GetRuleContext<ParameterDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public ParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParametersContext parameters() {
		ParametersContext _localctx = new ParametersContext(Context, State);
		EnterRule(_localctx, 148, RULE_parameters);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 763;
			Match(L_PAREN);
			State = 775;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 3)) & ~0x3f) == 0 && ((1L << (_la - 3)) & 2882304311860134339L) != 0)) {
				{
				State = 764;
				parameterDecl();
				State = 769;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,81,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 765;
						Match(COMMA);
						State = 766;
						parameterDecl();
						}
						} 
					}
					State = 771;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,81,Context);
				}
				State = 773;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 772;
					Match(COMMA);
					}
				}

				}
			}

			State = 777;
			Match(R_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELLIPSIS() { return GetToken(GoParser.ELLIPSIS, 0); }
		public ParameterDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterParameterDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitParameterDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterDeclContext parameterDecl() {
		ParameterDeclContext _localctx = new ParameterDeclContext(Context, State);
		EnterRule(_localctx, 150, RULE_parameterDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 780;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,84,Context) ) {
			case 1:
				{
				State = 779;
				identifierList();
				}
				break;
			}
			State = 783;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELLIPSIS) {
				{
				State = 782;
				Match(ELLIPSIS);
				}
			}

			State = 785;
			type_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public IToken unary_op;
		public IToken mul_op;
		public IToken add_op;
		public IToken rel_op;
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExprContext primaryExpr() {
			return GetRuleContext<PrimaryExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(GoParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(GoParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(GoParser.EXCLAMATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CARET() { return GetToken(GoParser.CARET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(GoParser.STAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND() { return GetToken(GoParser.AMPERSAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RECEIVE() { return GetToken(GoParser.RECEIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(GoParser.DIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(GoParser.MOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSHIFT() { return GetToken(GoParser.LSHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSHIFT() { return GetToken(GoParser.RSHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BIT_CLEAR() { return GetToken(GoParser.BIT_CLEAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(GoParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(GoParser.EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT_EQUALS() { return GetToken(GoParser.NOT_EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(GoParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_OR_EQUALS() { return GetToken(GoParser.LESS_OR_EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(GoParser.GREATER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_OR_EQUALS() { return GetToken(GoParser.GREATER_OR_EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGICAL_AND() { return GetToken(GoParser.LOGICAL_AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOGICAL_OR() { return GetToken(GoParser.LOGICAL_OR, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 152;
		EnterRecursionRule(_localctx, 152, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 791;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,86,Context) ) {
			case 1:
				{
				State = 788;
				primaryExpr(0);
				}
				break;
			case 2:
				{
				State = 789;
				_localctx.unary_op = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(((((_la - 58)) & ~0x3f) == 0 && ((1L << (_la - 58)) & 127L) != 0)) ) {
					_localctx.unary_op = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 790;
				expression(6);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 810;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,88,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 808;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,87,Context) ) {
					case 1:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 793;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 794;
						_localctx.mul_op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & -4472074429978902528L) != 0)) ) {
							_localctx.mul_op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 795;
						expression(6);
						}
						break;
					case 2:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 796;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 797;
						_localctx.add_op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 4037477065937649664L) != 0)) ) {
							_localctx.add_op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 798;
						expression(5);
						}
						break;
					case 3:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 799;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 800;
						_localctx.rel_op = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 2216615441596416L) != 0)) ) {
							_localctx.rel_op = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 801;
						expression(4);
						}
						break;
					case 4:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 802;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 803;
						Match(LOGICAL_AND);
						State = 804;
						expression(3);
						}
						break;
					case 5:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 805;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 806;
						Match(LOGICAL_OR);
						State = 807;
						expression(2);
						}
						break;
					}
					} 
				}
				State = 812;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,88,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class PrimaryExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OperandContext operand() {
			return GetRuleContext<OperandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConversionContext conversion() {
			return GetRuleContext<ConversionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MethodExprContext methodExpr() {
			return GetRuleContext<MethodExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryExprContext primaryExpr() {
			return GetRuleContext<PrimaryExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexContext index() {
			return GetRuleContext<IndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Slice_Context slice_() {
			return GetRuleContext<Slice_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeAssertionContext typeAssertion() {
			return GetRuleContext<TypeAssertionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public PrimaryExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterPrimaryExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitPrimaryExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExprContext primaryExpr() {
		return primaryExpr(0);
	}

	private PrimaryExprContext primaryExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		PrimaryExprContext _localctx = new PrimaryExprContext(Context, _parentState);
		PrimaryExprContext _prevctx = _localctx;
		int _startState = 154;
		EnterRecursionRule(_localctx, 154, RULE_primaryExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 817;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,89,Context) ) {
			case 1:
				{
				State = 814;
				operand();
				}
				break;
			case 2:
				{
				State = 815;
				conversion();
				}
				break;
			case 3:
				{
				State = 816;
				methodExpr();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 830;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,91,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new PrimaryExprContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_primaryExpr);
					State = 819;
					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
					State = 826;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,90,Context) ) {
					case 1:
						{
						State = 820;
						Match(DOT);
						State = 821;
						Match(IDENTIFIER);
						}
						break;
					case 2:
						{
						State = 822;
						index();
						}
						break;
					case 3:
						{
						State = 823;
						slice_();
						}
						break;
					case 4:
						{
						State = 824;
						typeAssertion();
						}
						break;
					case 5:
						{
						State = 825;
						arguments();
						}
						break;
					}
					}
					} 
				}
				State = 832;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,91,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ConversionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(GoParser.COMMA, 0); }
		public ConversionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conversion; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterConversion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitConversion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConversion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConversionContext conversion() {
		ConversionContext _localctx = new ConversionContext(Context, State);
		EnterRule(_localctx, 156, RULE_conversion);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 833;
			type_();
			State = 834;
			Match(L_PAREN);
			State = 835;
			expression(0);
			State = 837;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 836;
				Match(COMMA);
				}
			}

			State = 839;
			Match(R_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OperandNameContext operandName() {
			return GetRuleContext<OperandNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgsContext typeArgs() {
			return GetRuleContext<TypeArgsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		public OperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterOperand(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitOperand(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperandContext operand() {
		OperandContext _localctx = new OperandContext(Context, State);
		EnterRule(_localctx, 158, RULE_operand);
		try {
			State = 850;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,94,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 841;
				literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 842;
				operandName();
				State = 844;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,93,Context) ) {
				case 1:
					{
					State = 843;
					typeArgs();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 846;
				Match(L_PAREN);
				State = 847;
				expression(0);
				State = 848;
				Match(R_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BasicLitContext basicLit() {
			return GetRuleContext<BasicLitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CompositeLitContext compositeLit() {
			return GetRuleContext<CompositeLitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionLitContext functionLit() {
			return GetRuleContext<FunctionLitContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 160, RULE_literal);
		try {
			State = 855;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NIL_LIT:
			case DECIMAL_LIT:
			case BINARY_LIT:
			case OCTAL_LIT:
			case HEX_LIT:
			case FLOAT_LIT:
			case IMAGINARY_LIT:
			case RUNE_LIT:
			case RAW_STRING_LIT:
			case INTERPRETED_STRING_LIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 852;
				basicLit();
				}
				break;
			case MAP:
			case STRUCT:
			case IDENTIFIER:
			case L_BRACKET:
				EnterOuterAlt(_localctx, 2);
				{
				State = 853;
				compositeLit();
				}
				break;
			case FUNC:
				EnterOuterAlt(_localctx, 3);
				{
				State = 854;
				functionLit();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BasicLitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NIL_LIT() { return GetToken(GoParser.NIL_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public String_Context string_() {
			return GetRuleContext<String_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT_LIT() { return GetToken(GoParser.FLOAT_LIT, 0); }
		public BasicLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_basicLit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterBasicLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitBasicLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBasicLit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BasicLitContext basicLit() {
		BasicLitContext _localctx = new BasicLitContext(Context, State);
		EnterRule(_localctx, 162, RULE_basicLit);
		try {
			State = 861;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NIL_LIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 857;
				Match(NIL_LIT);
				}
				break;
			case DECIMAL_LIT:
			case BINARY_LIT:
			case OCTAL_LIT:
			case HEX_LIT:
			case IMAGINARY_LIT:
			case RUNE_LIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 858;
				integer();
				}
				break;
			case RAW_STRING_LIT:
			case INTERPRETED_STRING_LIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 859;
				string_();
				}
				break;
			case FLOAT_LIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 860;
				Match(FLOAT_LIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECIMAL_LIT() { return GetToken(GoParser.DECIMAL_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINARY_LIT() { return GetToken(GoParser.BINARY_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OCTAL_LIT() { return GetToken(GoParser.OCTAL_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEX_LIT() { return GetToken(GoParser.HEX_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMAGINARY_LIT() { return GetToken(GoParser.IMAGINARY_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RUNE_LIT() { return GetToken(GoParser.RUNE_LIT, 0); }
		public IntegerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterInteger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitInteger(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntegerContext integer() {
		IntegerContext _localctx = new IntegerContext(Context, State);
		EnterRule(_localctx, 164, RULE_integer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 863;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 399L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperandNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public OperandNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operandName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterOperandName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitOperandName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperandName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperandNameContext operandName() {
		OperandNameContext _localctx = new OperandNameContext(Context, State);
		EnterRule(_localctx, 166, RULE_operandName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 865;
			Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedIdentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IDENTIFIER() { return GetTokens(GoParser.IDENTIFIER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER(int i) {
			return GetToken(GoParser.IDENTIFIER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		public QualifiedIdentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedIdent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterQualifiedIdent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitQualifiedIdent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifiedIdent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedIdentContext qualifiedIdent() {
		QualifiedIdentContext _localctx = new QualifiedIdentContext(Context, State);
		EnterRule(_localctx, 168, RULE_qualifiedIdent);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 867;
			Match(IDENTIFIER);
			State = 868;
			Match(DOT);
			State = 869;
			Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CompositeLitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralTypeContext literalType() {
			return GetRuleContext<LiteralTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralValueContext literalValue() {
			return GetRuleContext<LiteralValueContext>(0);
		}
		public CompositeLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compositeLit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterCompositeLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitCompositeLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompositeLit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompositeLitContext compositeLit() {
		CompositeLitContext _localctx = new CompositeLitContext(Context, State);
		EnterRule(_localctx, 170, RULE_compositeLit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 871;
			literalType();
			State = 872;
			literalValue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StructTypeContext structType() {
			return GetRuleContext<StructTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrayTypeContext arrayType() {
			return GetRuleContext<ArrayTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELLIPSIS() { return GetToken(GoParser.ELLIPSIS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementTypeContext elementType() {
			return GetRuleContext<ElementTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SliceTypeContext sliceType() {
			return GetRuleContext<SliceTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapTypeContext mapType() {
			return GetRuleContext<MapTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgsContext typeArgs() {
			return GetRuleContext<TypeArgsContext>(0);
		}
		public LiteralTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterLiteralType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitLiteralType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralTypeContext literalType() {
		LiteralTypeContext _localctx = new LiteralTypeContext(Context, State);
		EnterRule(_localctx, 172, RULE_literalType);
		int _la;
		try {
			State = 886;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,98,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 874;
				structType();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 875;
				arrayType();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 876;
				Match(L_BRACKET);
				State = 877;
				Match(ELLIPSIS);
				State = 878;
				Match(R_BRACKET);
				State = 879;
				elementType();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 880;
				sliceType();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 881;
				mapType();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 882;
				typeName();
				State = 884;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==L_BRACKET) {
					{
					State = 883;
					typeArgs();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementListContext elementList() {
			return GetRuleContext<ElementListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(GoParser.COMMA, 0); }
		public LiteralValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterLiteralValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitLiteralValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralValueContext literalValue() {
		LiteralValueContext _localctx = new LiteralValueContext(Context, State);
		EnterRule(_localctx, 174, RULE_literalValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 888;
			Match(L_CURLY);
			State = 893;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230370313236968L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
				{
				State = 889;
				elementList();
				State = 891;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 890;
					Match(COMMA);
					}
				}

				}
			}

			State = 895;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public KeyedElementContext[] keyedElement() {
			return GetRuleContexts<KeyedElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyedElementContext keyedElement(int i) {
			return GetRuleContext<KeyedElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public ElementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterElementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitElementList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementListContext elementList() {
		ElementListContext _localctx = new ElementListContext(Context, State);
		EnterRule(_localctx, 176, RULE_elementList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 897;
			keyedElement();
			State = 902;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,101,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 898;
					Match(COMMA);
					State = 899;
					keyedElement();
					}
					} 
				}
				State = 904;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,101,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeyedElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementContext element() {
			return GetRuleContext<ElementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public KeyContext key() {
			return GetRuleContext<KeyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(GoParser.COLON, 0); }
		public KeyedElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyedElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterKeyedElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitKeyedElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyedElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeyedElementContext keyedElement() {
		KeyedElementContext _localctx = new KeyedElementContext(Context, State);
		EnterRule(_localctx, 178, RULE_keyedElement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 908;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,102,Context) ) {
			case 1:
				{
				State = 905;
				key();
				State = 906;
				Match(COLON);
				}
				break;
			}
			State = 910;
			element();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralValueContext literalValue() {
			return GetRuleContext<LiteralValueContext>(0);
		}
		public KeyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_key; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitKey(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKey(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeyContext key() {
		KeyContext _localctx = new KeyContext(Context, State);
		EnterRule(_localctx, 180, RULE_key);
		try {
			State = 914;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FUNC:
			case INTERFACE:
			case MAP:
			case STRUCT:
			case CHAN:
			case NIL_LIT:
			case IDENTIFIER:
			case L_PAREN:
			case L_BRACKET:
			case EXCLAMATION:
			case PLUS:
			case MINUS:
			case CARET:
			case STAR:
			case AMPERSAND:
			case RECEIVE:
			case DECIMAL_LIT:
			case BINARY_LIT:
			case OCTAL_LIT:
			case HEX_LIT:
			case FLOAT_LIT:
			case IMAGINARY_LIT:
			case RUNE_LIT:
			case RAW_STRING_LIT:
			case INTERPRETED_STRING_LIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 912;
				expression(0);
				}
				break;
			case L_CURLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 913;
				literalValue();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralValueContext literalValue() {
			return GetRuleContext<LiteralValueContext>(0);
		}
		public ElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementContext element() {
		ElementContext _localctx = new ElementContext(Context, State);
		EnterRule(_localctx, 182, RULE_element);
		try {
			State = 918;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FUNC:
			case INTERFACE:
			case MAP:
			case STRUCT:
			case CHAN:
			case NIL_LIT:
			case IDENTIFIER:
			case L_PAREN:
			case L_BRACKET:
			case EXCLAMATION:
			case PLUS:
			case MINUS:
			case CARET:
			case STAR:
			case AMPERSAND:
			case RECEIVE:
			case DECIMAL_LIT:
			case BINARY_LIT:
			case OCTAL_LIT:
			case HEX_LIT:
			case FLOAT_LIT:
			case IMAGINARY_LIT:
			case RUNE_LIT:
			case RAW_STRING_LIT:
			case INTERPRETED_STRING_LIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 916;
				expression(0);
				}
				break;
			case L_CURLY:
				EnterOuterAlt(_localctx, 2);
				{
				State = 917;
				literalValue();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRUCT() { return GetToken(GoParser.STRUCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_CURLY() { return GetToken(GoParser.L_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_CURLY() { return GetToken(GoParser.R_CURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FieldDeclContext[] fieldDecl() {
			return GetRuleContexts<FieldDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FieldDeclContext fieldDecl(int i) {
			return GetRuleContext<FieldDeclContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public StructTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterStructType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitStructType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructTypeContext structType() {
		StructTypeContext _localctx = new StructTypeContext(Context, State);
		EnterRule(_localctx, 184, RULE_structType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 920;
			Match(STRUCT);
			State = 921;
			Match(L_CURLY);
			State = 927;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IDENTIFIER || _la==STAR) {
				{
				{
				State = 922;
				fieldDecl();
				State = 923;
				eos();
				}
				}
				State = 929;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 930;
			Match(R_CURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldDeclContext : ParserRuleContext {
		public String_Context tag;
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierListContext identifierList() {
			return GetRuleContext<IdentifierListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EmbeddedFieldContext embeddedField() {
			return GetRuleContext<EmbeddedFieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public String_Context string_() {
			return GetRuleContext<String_Context>(0);
		}
		public FieldDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterFieldDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitFieldDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFieldDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FieldDeclContext fieldDecl() {
		FieldDeclContext _localctx = new FieldDeclContext(Context, State);
		EnterRule(_localctx, 186, RULE_fieldDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 936;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,106,Context) ) {
			case 1:
				{
				State = 932;
				identifierList();
				State = 933;
				type_();
				}
				break;
			case 2:
				{
				State = 935;
				embeddedField();
				}
				break;
			}
			State = 939;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
			case 1:
				{
				State = 938;
				_localctx.tag = string_();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RAW_STRING_LIT() { return GetToken(GoParser.RAW_STRING_LIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERPRETED_STRING_LIT() { return GetToken(GoParser.INTERPRETED_STRING_LIT, 0); }
		public String_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterString_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitString_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_Context string_() {
		String_Context _localctx = new String_Context(Context, State);
		EnterRule(_localctx, 188, RULE_string_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 941;
			_la = TokenStream.LA(1);
			if ( !(_la==RAW_STRING_LIT || _la==INTERPRETED_STRING_LIT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EmbeddedFieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(GoParser.STAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgsContext typeArgs() {
			return GetRuleContext<TypeArgsContext>(0);
		}
		public EmbeddedFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_embeddedField; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterEmbeddedField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitEmbeddedField(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEmbeddedField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EmbeddedFieldContext embeddedField() {
		EmbeddedFieldContext _localctx = new EmbeddedFieldContext(Context, State);
		EnterRule(_localctx, 190, RULE_embeddedField);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 944;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STAR) {
				{
				State = 943;
				Match(STAR);
				}
			}

			State = 946;
			typeName();
			State = 948;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,109,Context) ) {
			case 1:
				{
				State = 947;
				typeArgs();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionLitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNC() { return GetToken(GoParser.FUNC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignatureContext signature() {
			return GetRuleContext<SignatureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public FunctionLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionLit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterFunctionLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitFunctionLit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionLit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionLitContext functionLit() {
		FunctionLitContext _localctx = new FunctionLitContext(Context, State);
		EnterRule(_localctx, 192, RULE_functionLit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 950;
			Match(FUNC);
			State = 951;
			signature();
			State = 952;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		public IndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitIndex(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexContext index() {
		IndexContext _localctx = new IndexContext(Context, State);
		EnterRule(_localctx, 194, RULE_index);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 954;
			Match(L_BRACKET);
			State = 955;
			expression(0);
			State = 956;
			Match(R_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Slice_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_BRACKET() { return GetToken(GoParser.L_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_BRACKET() { return GetToken(GoParser.R_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(GoParser.COLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON(int i) {
			return GetToken(GoParser.COLON, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Slice_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_slice_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterSlice_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitSlice_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSlice_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Slice_Context slice_() {
		Slice_Context _localctx = new Slice_Context(Context, State);
		EnterRule(_localctx, 196, RULE_slice_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 958;
			Match(L_BRACKET);
			State = 974;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,113,Context) ) {
			case 1:
				{
				State = 960;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 959;
					expression(0);
					}
				}

				State = 962;
				Match(COLON);
				State = 964;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 963;
					expression(0);
					}
				}

				}
				break;
			case 2:
				{
				State = 967;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
					{
					State = 966;
					expression(0);
					}
				}

				State = 969;
				Match(COLON);
				State = 970;
				expression(0);
				State = 971;
				Match(COLON);
				State = 972;
				expression(0);
				}
				break;
			}
			State = 976;
			Match(R_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeAssertionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		public TypeAssertionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeAssertion; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterTypeAssertion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitTypeAssertion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeAssertion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeAssertionContext typeAssertion() {
		TypeAssertionContext _localctx = new TypeAssertionContext(Context, State);
		EnterRule(_localctx, 198, RULE_typeAssertion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 978;
			Match(DOT);
			State = 979;
			Match(L_PAREN);
			State = 980;
			type_();
			State = 981;
			Match(R_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode L_PAREN() { return GetToken(GoParser.L_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode R_PAREN() { return GetToken(GoParser.R_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELLIPSIS() { return GetToken(GoParser.ELLIPSIS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(GoParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(GoParser.COMMA, i);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 200, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 983;
			Match(L_PAREN);
			State = 998;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -288230371386978792L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 99135L) != 0)) {
				{
				State = 990;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,115,Context) ) {
				case 1:
					{
					State = 984;
					expressionList();
					}
					break;
				case 2:
					{
					State = 985;
					type_();
					State = 988;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,114,Context) ) {
					case 1:
						{
						State = 986;
						Match(COMMA);
						State = 987;
						expressionList();
						}
						break;
					}
					}
					break;
				}
				State = 993;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELLIPSIS) {
					{
					State = 992;
					Match(ELLIPSIS);
					}
				}

				State = 996;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 995;
					Match(COMMA);
					}
				}

				}
			}

			State = 1000;
			Match(R_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Type_Context type_() {
			return GetRuleContext<Type_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(GoParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(GoParser.IDENTIFIER, 0); }
		public MethodExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterMethodExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitMethodExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodExprContext methodExpr() {
		MethodExprContext _localctx = new MethodExprContext(Context, State);
		EnterRule(_localctx, 202, RULE_methodExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1002;
			type_();
			State = 1003;
			Match(DOT);
			State = 1004;
			Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EosContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMI() { return GetToken(GoParser.SEMI, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(GoParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EOS() { return GetToken(GoParser.EOS, 0); }
		public EosContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eos; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.EnterEos(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IGoParserListener typedListener = listener as IGoParserListener;
			if (typedListener != null) typedListener.ExitEos(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGoParserVisitor<TResult> typedVisitor = visitor as IGoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEos(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EosContext eos() {
		EosContext _localctx = new EosContext(Context, State);
		EnterRule(_localctx, 204, RULE_eos);
		try {
			State = 1010;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,119,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1006;
				Match(SEMI);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1007;
				Match(Eof);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1008;
				Match(EOS);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1009;
				if (!(this.closingBracket())) throw new FailedPredicateException(this, "this.closingBracket()");
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 24: return statementList_sempred((StatementListContext)_localctx, predIndex);
		case 76: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 77: return primaryExpr_sempred((PrimaryExprContext)_localctx, predIndex);
		case 102: return eos_sempred((EosContext)_localctx, predIndex);
		}
		return true;
	}
	private bool statementList_sempred(StatementListContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return this.closingBracket();
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 5);
		case 2: return Precpred(Context, 4);
		case 3: return Precpred(Context, 3);
		case 4: return Precpred(Context, 2);
		case 5: return Precpred(Context, 1);
		}
		return true;
	}
	private bool primaryExpr_sempred(PrimaryExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 1);
		}
		return true;
	}
	private bool eos_sempred(EosContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return this.closingBracket();
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,89,1013,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
		7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,
		2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,
		2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,
		2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,91,
		2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,98,
		2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,1,0,1,0,1,0,1,0,1,0,5,0,
		212,8,0,10,0,12,0,215,9,0,1,0,1,0,1,0,3,0,220,8,0,1,0,1,0,5,0,224,8,0,
		10,0,12,0,227,9,0,1,0,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,5,2,240,
		8,2,10,2,12,2,243,9,2,1,2,3,2,246,8,2,1,3,3,3,249,8,3,1,3,1,3,1,4,1,4,
		1,5,1,5,1,5,3,5,258,8,5,1,6,1,6,1,6,1,6,1,6,1,6,5,6,266,8,6,10,6,12,6,
		269,9,6,1,6,3,6,272,8,6,1,7,1,7,3,7,276,8,7,1,7,1,7,3,7,280,8,7,1,8,1,
		8,1,8,5,8,285,8,8,10,8,12,8,288,9,8,1,9,1,9,1,9,5,9,293,8,9,10,9,12,9,
		296,9,9,1,10,1,10,1,10,1,10,1,10,1,10,5,10,304,8,10,10,10,12,10,307,9,
		10,1,10,3,10,310,8,10,1,11,1,11,3,11,314,8,11,1,12,1,12,1,12,1,12,1,13,
		1,13,3,13,322,8,13,1,13,1,13,1,14,1,14,1,14,1,14,5,14,330,8,14,10,14,12,
		14,333,9,14,1,14,1,14,1,15,1,15,1,15,1,16,1,16,1,16,5,16,343,8,16,10,16,
		12,16,346,9,16,1,17,3,17,349,8,17,1,17,1,17,1,18,1,18,1,18,3,18,356,8,
		18,1,18,1,18,3,18,360,8,18,1,19,1,19,1,19,1,19,1,19,3,19,367,8,19,1,20,
		1,20,1,21,1,21,1,21,1,21,1,21,1,21,5,21,377,8,21,10,21,12,21,380,9,21,
		1,21,3,21,383,8,21,1,22,1,22,1,22,1,22,3,22,389,8,22,1,22,1,22,3,22,393,
		8,22,1,23,1,23,3,23,397,8,23,1,23,1,23,1,24,3,24,402,8,24,1,24,3,24,405,
		8,24,1,24,3,24,408,8,24,1,24,1,24,1,24,4,24,413,8,24,11,24,12,24,414,1,
		25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,
		25,3,25,432,8,25,1,26,1,26,1,26,1,26,1,26,3,26,439,8,26,1,27,1,27,1,28,
		1,28,1,28,1,28,1,29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,3,31,455,8,31,1,
		31,1,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,3,33,466,8,33,1,34,1,34,3,34,
		470,8,34,1,35,1,35,3,35,474,8,35,1,36,1,36,3,36,478,8,36,1,37,1,37,1,37,
		1,38,1,38,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,
		3,40,497,8,40,1,40,1,40,1,40,1,40,3,40,503,8,40,3,40,505,8,40,1,41,1,41,
		3,41,509,8,41,1,42,1,42,3,42,513,8,42,1,42,3,42,516,8,42,1,42,1,42,3,42,
		520,8,42,3,42,522,8,42,1,42,1,42,5,42,526,8,42,10,42,12,42,529,9,42,1,
		42,1,42,1,43,1,43,1,43,3,43,536,8,43,1,44,1,44,1,44,3,44,541,8,44,1,45,
		1,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,3,45,552,8,45,1,45,1,45,5,45,556,
		8,45,10,45,12,45,559,9,45,1,45,1,45,1,46,1,46,3,46,565,8,46,1,46,1,46,
		1,46,1,46,1,46,1,46,1,47,1,47,1,47,3,47,576,8,47,1,48,1,48,1,48,3,48,581,
		8,48,1,49,1,49,3,49,585,8,49,1,49,1,49,1,49,3,49,590,8,49,5,49,592,8,49,
		10,49,12,49,595,9,49,1,50,1,50,1,50,5,50,600,8,50,10,50,12,50,603,9,50,
		1,50,1,50,1,51,1,51,1,51,3,51,610,8,51,1,52,1,52,1,52,3,52,615,8,52,1,
		52,3,52,618,8,52,1,53,1,53,1,53,1,53,1,53,1,53,3,53,626,8,53,1,53,1,53,
		1,54,1,54,3,54,632,8,54,1,54,1,54,3,54,636,8,54,3,54,638,8,54,1,54,1,54,
		1,55,3,55,643,8,55,1,55,1,55,3,55,647,8,55,1,55,1,55,3,55,651,8,55,1,56,
		1,56,1,56,1,56,1,56,1,56,3,56,659,8,56,1,56,1,56,1,56,1,57,1,57,1,57,1,
		58,1,58,3,58,669,8,58,1,58,1,58,1,58,1,58,1,58,3,58,676,8,58,1,59,1,59,
		1,59,3,59,681,8,59,1,59,1,59,1,60,1,60,3,60,687,8,60,1,61,1,61,1,61,1,
		61,1,61,1,61,1,61,1,61,3,61,697,8,61,1,62,1,62,1,62,1,62,1,62,1,63,1,63,
		1,64,1,64,1,65,1,65,1,65,1,66,1,66,1,66,1,66,3,66,715,8,66,1,66,1,66,5,
		66,719,8,66,10,66,12,66,722,9,66,1,66,1,66,1,67,1,67,1,67,1,67,1,68,1,
		68,1,68,1,68,1,68,1,68,1,69,1,69,1,69,1,69,1,69,3,69,741,8,69,1,69,1,69,
		1,70,1,70,1,70,1,70,1,70,1,70,3,70,751,8,70,1,71,1,71,1,71,1,72,1,72,3,
		72,758,8,72,1,73,1,73,3,73,762,8,73,1,74,1,74,1,74,1,74,5,74,768,8,74,
		10,74,12,74,771,9,74,1,74,3,74,774,8,74,3,74,776,8,74,1,74,1,74,1,75,3,
		75,781,8,75,1,75,3,75,784,8,75,1,75,1,75,1,76,1,76,1,76,1,76,3,76,792,
		8,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,
		1,76,1,76,5,76,809,8,76,10,76,12,76,812,9,76,1,77,1,77,1,77,1,77,3,77,
		818,8,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,3,77,827,8,77,5,77,829,8,77,
		10,77,12,77,832,9,77,1,78,1,78,1,78,1,78,3,78,838,8,78,1,78,1,78,1,79,
		1,79,1,79,3,79,845,8,79,1,79,1,79,1,79,1,79,3,79,851,8,79,1,80,1,80,1,
		80,3,80,856,8,80,1,81,1,81,1,81,1,81,3,81,862,8,81,1,82,1,82,1,83,1,83,
		1,84,1,84,1,84,1,84,1,85,1,85,1,85,1,86,1,86,1,86,1,86,1,86,1,86,1,86,
		1,86,1,86,1,86,3,86,885,8,86,3,86,887,8,86,1,87,1,87,1,87,3,87,892,8,87,
		3,87,894,8,87,1,87,1,87,1,88,1,88,1,88,5,88,901,8,88,10,88,12,88,904,9,
		88,1,89,1,89,1,89,3,89,909,8,89,1,89,1,89,1,90,1,90,3,90,915,8,90,1,91,
		1,91,3,91,919,8,91,1,92,1,92,1,92,1,92,1,92,5,92,926,8,92,10,92,12,92,
		929,9,92,1,92,1,92,1,93,1,93,1,93,1,93,3,93,937,8,93,1,93,3,93,940,8,93,
		1,94,1,94,1,95,3,95,945,8,95,1,95,1,95,3,95,949,8,95,1,96,1,96,1,96,1,
		96,1,97,1,97,1,97,1,97,1,98,1,98,3,98,961,8,98,1,98,1,98,3,98,965,8,98,
		1,98,3,98,968,8,98,1,98,1,98,1,98,1,98,1,98,3,98,975,8,98,1,98,1,98,1,
		99,1,99,1,99,1,99,1,99,1,100,1,100,1,100,1,100,1,100,3,100,989,8,100,3,
		100,991,8,100,1,100,3,100,994,8,100,1,100,3,100,997,8,100,3,100,999,8,
		100,1,100,1,100,1,101,1,101,1,101,1,101,1,102,1,102,1,102,1,102,3,102,
		1011,8,102,1,102,0,2,152,154,103,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
		28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,
		76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
		118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
		154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,
		190,192,194,196,198,200,202,204,0,9,2,0,27,27,38,38,1,0,39,40,2,0,51,56,
		59,63,1,0,58,64,2,0,52,56,62,63,2,0,51,51,59,61,1,0,45,50,2,0,65,68,72,
		73,1,0,79,80,1078,0,206,1,0,0,0,2,230,1,0,0,0,4,233,1,0,0,0,6,248,1,0,
		0,0,8,252,1,0,0,0,10,257,1,0,0,0,12,259,1,0,0,0,14,273,1,0,0,0,16,281,
		1,0,0,0,18,289,1,0,0,0,20,297,1,0,0,0,22,313,1,0,0,0,24,315,1,0,0,0,26,
		319,1,0,0,0,28,325,1,0,0,0,30,336,1,0,0,0,32,339,1,0,0,0,34,348,1,0,0,
		0,36,352,1,0,0,0,38,361,1,0,0,0,40,368,1,0,0,0,42,370,1,0,0,0,44,384,1,
		0,0,0,46,394,1,0,0,0,48,412,1,0,0,0,50,431,1,0,0,0,52,438,1,0,0,0,54,440,
		1,0,0,0,56,442,1,0,0,0,58,446,1,0,0,0,60,449,1,0,0,0,62,454,1,0,0,0,64,
		458,1,0,0,0,66,462,1,0,0,0,68,467,1,0,0,0,70,471,1,0,0,0,72,475,1,0,0,
		0,74,479,1,0,0,0,76,482,1,0,0,0,78,484,1,0,0,0,80,487,1,0,0,0,82,508,1,
		0,0,0,84,510,1,0,0,0,86,532,1,0,0,0,88,540,1,0,0,0,90,542,1,0,0,0,92,564,
		1,0,0,0,94,572,1,0,0,0,96,580,1,0,0,0,98,584,1,0,0,0,100,596,1,0,0,0,102,
		606,1,0,0,0,104,617,1,0,0,0,106,625,1,0,0,0,108,629,1,0,0,0,110,642,1,
		0,0,0,112,658,1,0,0,0,114,663,1,0,0,0,116,675,1,0,0,0,118,677,1,0,0,0,
		120,686,1,0,0,0,122,696,1,0,0,0,124,698,1,0,0,0,126,703,1,0,0,0,128,705,
		1,0,0,0,130,707,1,0,0,0,132,710,1,0,0,0,134,725,1,0,0,0,136,729,1,0,0,
		0,138,740,1,0,0,0,140,750,1,0,0,0,142,752,1,0,0,0,144,755,1,0,0,0,146,
		761,1,0,0,0,148,763,1,0,0,0,150,780,1,0,0,0,152,791,1,0,0,0,154,817,1,
		0,0,0,156,833,1,0,0,0,158,850,1,0,0,0,160,855,1,0,0,0,162,861,1,0,0,0,
		164,863,1,0,0,0,166,865,1,0,0,0,168,867,1,0,0,0,170,871,1,0,0,0,172,886,
		1,0,0,0,174,888,1,0,0,0,176,897,1,0,0,0,178,908,1,0,0,0,180,914,1,0,0,
		0,182,918,1,0,0,0,184,920,1,0,0,0,186,936,1,0,0,0,188,941,1,0,0,0,190,
		944,1,0,0,0,192,950,1,0,0,0,194,954,1,0,0,0,196,958,1,0,0,0,198,978,1,
		0,0,0,200,983,1,0,0,0,202,1002,1,0,0,0,204,1010,1,0,0,0,206,207,3,2,1,
		0,207,213,3,204,102,0,208,209,3,4,2,0,209,210,3,204,102,0,210,212,1,0,
		0,0,211,208,1,0,0,0,212,215,1,0,0,0,213,211,1,0,0,0,213,214,1,0,0,0,214,
		225,1,0,0,0,215,213,1,0,0,0,216,220,3,36,18,0,217,220,3,38,19,0,218,220,
		3,10,5,0,219,216,1,0,0,0,219,217,1,0,0,0,219,218,1,0,0,0,220,221,1,0,0,
		0,221,222,3,204,102,0,222,224,1,0,0,0,223,219,1,0,0,0,224,227,1,0,0,0,
		225,223,1,0,0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,225,1,0,0,0,228,229,
		5,0,0,1,229,1,1,0,0,0,230,231,5,14,0,0,231,232,5,27,0,0,232,3,1,0,0,0,
		233,245,5,23,0,0,234,246,3,6,3,0,235,241,5,28,0,0,236,237,3,6,3,0,237,
		238,3,204,102,0,238,240,1,0,0,0,239,236,1,0,0,0,240,243,1,0,0,0,241,239,
		1,0,0,0,241,242,1,0,0,0,242,244,1,0,0,0,243,241,1,0,0,0,244,246,5,29,0,
		0,245,234,1,0,0,0,245,235,1,0,0,0,246,5,1,0,0,0,247,249,7,0,0,0,248,247,
		1,0,0,0,248,249,1,0,0,0,249,250,1,0,0,0,250,251,3,8,4,0,251,7,1,0,0,0,
		252,253,3,188,94,0,253,9,1,0,0,0,254,258,3,12,6,0,255,258,3,20,10,0,256,
		258,3,42,21,0,257,254,1,0,0,0,257,255,1,0,0,0,257,256,1,0,0,0,258,11,1,
		0,0,0,259,271,5,16,0,0,260,272,3,14,7,0,261,267,5,28,0,0,262,263,3,14,
		7,0,263,264,3,204,102,0,264,266,1,0,0,0,265,262,1,0,0,0,266,269,1,0,0,
		0,267,265,1,0,0,0,267,268,1,0,0,0,268,270,1,0,0,0,269,267,1,0,0,0,270,
		272,5,29,0,0,271,260,1,0,0,0,271,261,1,0,0,0,272,13,1,0,0,0,273,279,3,
		16,8,0,274,276,3,116,58,0,275,274,1,0,0,0,275,276,1,0,0,0,276,277,1,0,
		0,0,277,278,5,34,0,0,278,280,3,18,9,0,279,275,1,0,0,0,279,280,1,0,0,0,
		280,15,1,0,0,0,281,286,5,27,0,0,282,283,5,35,0,0,283,285,5,27,0,0,284,
		282,1,0,0,0,285,288,1,0,0,0,286,284,1,0,0,0,286,287,1,0,0,0,287,17,1,0,
		0,0,288,286,1,0,0,0,289,294,3,152,76,0,290,291,5,35,0,0,291,293,3,152,
		76,0,292,290,1,0,0,0,293,296,1,0,0,0,294,292,1,0,0,0,294,295,1,0,0,0,295,
		19,1,0,0,0,296,294,1,0,0,0,297,309,5,20,0,0,298,310,3,22,11,0,299,305,
		5,28,0,0,300,301,3,22,11,0,301,302,3,204,102,0,302,304,1,0,0,0,303,300,
		1,0,0,0,304,307,1,0,0,0,305,303,1,0,0,0,305,306,1,0,0,0,306,308,1,0,0,
		0,307,305,1,0,0,0,308,310,5,29,0,0,309,298,1,0,0,0,309,299,1,0,0,0,310,
		21,1,0,0,0,311,314,3,24,12,0,312,314,3,26,13,0,313,311,1,0,0,0,313,312,
		1,0,0,0,314,23,1,0,0,0,315,316,5,27,0,0,316,317,5,34,0,0,317,318,3,116,
		58,0,318,25,1,0,0,0,319,321,5,27,0,0,320,322,3,28,14,0,321,320,1,0,0,0,
		321,322,1,0,0,0,322,323,1,0,0,0,323,324,3,116,58,0,324,27,1,0,0,0,325,
		326,5,32,0,0,326,331,3,30,15,0,327,328,5,35,0,0,328,330,3,30,15,0,329,
		327,1,0,0,0,330,333,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,0,332,334,1,
		0,0,0,333,331,1,0,0,0,334,335,5,33,0,0,335,29,1,0,0,0,336,337,3,16,8,0,
		337,338,3,32,16,0,338,31,1,0,0,0,339,344,3,34,17,0,340,341,5,51,0,0,341,
		343,3,34,17,0,342,340,1,0,0,0,343,346,1,0,0,0,344,342,1,0,0,0,344,345,
		1,0,0,0,345,33,1,0,0,0,346,344,1,0,0,0,347,349,5,57,0,0,348,347,1,0,0,
		0,348,349,1,0,0,0,349,350,1,0,0,0,350,351,3,116,58,0,351,35,1,0,0,0,352,
		353,5,3,0,0,353,355,5,27,0,0,354,356,3,28,14,0,355,354,1,0,0,0,355,356,
		1,0,0,0,356,357,1,0,0,0,357,359,3,144,72,0,358,360,3,46,23,0,359,358,1,
		0,0,0,359,360,1,0,0,0,360,37,1,0,0,0,361,362,5,3,0,0,362,363,3,40,20,0,
		363,364,5,27,0,0,364,366,3,144,72,0,365,367,3,46,23,0,366,365,1,0,0,0,
		366,367,1,0,0,0,367,39,1,0,0,0,368,369,3,148,74,0,369,41,1,0,0,0,370,382,
		5,25,0,0,371,383,3,44,22,0,372,378,5,28,0,0,373,374,3,44,22,0,374,375,
		3,204,102,0,375,377,1,0,0,0,376,373,1,0,0,0,377,380,1,0,0,0,378,376,1,
		0,0,0,378,379,1,0,0,0,379,381,1,0,0,0,380,378,1,0,0,0,381,383,5,29,0,0,
		382,371,1,0,0,0,382,372,1,0,0,0,383,43,1,0,0,0,384,392,3,16,8,0,385,388,
		3,116,58,0,386,387,5,34,0,0,387,389,3,18,9,0,388,386,1,0,0,0,388,389,1,
		0,0,0,389,393,1,0,0,0,390,391,5,34,0,0,391,393,3,18,9,0,392,385,1,0,0,
		0,392,390,1,0,0,0,393,45,1,0,0,0,394,396,5,30,0,0,395,397,3,48,24,0,396,
		395,1,0,0,0,396,397,1,0,0,0,397,398,1,0,0,0,398,399,5,31,0,0,399,47,1,
		0,0,0,400,402,5,36,0,0,401,400,1,0,0,0,401,402,1,0,0,0,402,408,1,0,0,0,
		403,405,5,88,0,0,404,403,1,0,0,0,404,405,1,0,0,0,405,408,1,0,0,0,406,408,
		4,24,0,0,407,401,1,0,0,0,407,404,1,0,0,0,407,406,1,0,0,0,408,409,1,0,0,
		0,409,410,3,50,25,0,410,411,3,204,102,0,411,413,1,0,0,0,412,407,1,0,0,
		0,413,414,1,0,0,0,414,412,1,0,0,0,414,415,1,0,0,0,415,49,1,0,0,0,416,432,
		3,10,5,0,417,432,3,66,33,0,418,432,3,52,26,0,419,432,3,114,57,0,420,432,
		3,68,34,0,421,432,3,70,35,0,422,432,3,72,36,0,423,432,3,74,37,0,424,432,
		3,76,38,0,425,432,3,46,23,0,426,432,3,80,40,0,427,432,3,82,41,0,428,432,
		3,100,50,0,429,432,3,108,54,0,430,432,3,78,39,0,431,416,1,0,0,0,431,417,
		1,0,0,0,431,418,1,0,0,0,431,419,1,0,0,0,431,420,1,0,0,0,431,421,1,0,0,
		0,431,422,1,0,0,0,431,423,1,0,0,0,431,424,1,0,0,0,431,425,1,0,0,0,431,
		426,1,0,0,0,431,427,1,0,0,0,431,428,1,0,0,0,431,429,1,0,0,0,431,430,1,
		0,0,0,432,51,1,0,0,0,433,439,3,56,28,0,434,439,3,58,29,0,435,439,3,60,
		30,0,436,439,3,54,27,0,437,439,3,64,32,0,438,433,1,0,0,0,438,434,1,0,0,
		0,438,435,1,0,0,0,438,436,1,0,0,0,438,437,1,0,0,0,439,53,1,0,0,0,440,441,
		3,152,76,0,441,55,1,0,0,0,442,443,3,152,76,0,443,444,5,64,0,0,444,445,
		3,152,76,0,445,57,1,0,0,0,446,447,3,152,76,0,447,448,7,1,0,0,448,59,1,
		0,0,0,449,450,3,18,9,0,450,451,3,62,31,0,451,452,3,18,9,0,452,61,1,0,0,
		0,453,455,7,2,0,0,454,453,1,0,0,0,454,455,1,0,0,0,455,456,1,0,0,0,456,
		457,5,34,0,0,457,63,1,0,0,0,458,459,3,16,8,0,459,460,5,41,0,0,460,461,
		3,18,9,0,461,65,1,0,0,0,462,463,5,27,0,0,463,465,5,37,0,0,464,466,3,50,
		25,0,465,464,1,0,0,0,465,466,1,0,0,0,466,67,1,0,0,0,467,469,5,24,0,0,468,
		470,3,18,9,0,469,468,1,0,0,0,469,470,1,0,0,0,470,69,1,0,0,0,471,473,5,
		1,0,0,472,474,5,27,0,0,473,472,1,0,0,0,473,474,1,0,0,0,474,71,1,0,0,0,
		475,477,5,21,0,0,476,478,5,27,0,0,477,476,1,0,0,0,477,478,1,0,0,0,478,
		73,1,0,0,0,479,480,5,13,0,0,480,481,5,27,0,0,481,75,1,0,0,0,482,483,5,
		17,0,0,483,77,1,0,0,0,484,485,5,7,0,0,485,486,3,152,76,0,486,79,1,0,0,
		0,487,496,5,18,0,0,488,497,3,152,76,0,489,490,3,204,102,0,490,491,3,152,
		76,0,491,497,1,0,0,0,492,493,3,52,26,0,493,494,3,204,102,0,494,495,3,152,
		76,0,495,497,1,0,0,0,496,488,1,0,0,0,496,489,1,0,0,0,496,492,1,0,0,0,497,
		498,1,0,0,0,498,504,3,46,23,0,499,502,5,12,0,0,500,503,3,80,40,0,501,503,
		3,46,23,0,502,500,1,0,0,0,502,501,1,0,0,0,503,505,1,0,0,0,504,499,1,0,
		0,0,504,505,1,0,0,0,505,81,1,0,0,0,506,509,3,84,42,0,507,509,3,90,45,0,
		508,506,1,0,0,0,508,507,1,0,0,0,509,83,1,0,0,0,510,521,5,15,0,0,511,513,
		3,152,76,0,512,511,1,0,0,0,512,513,1,0,0,0,513,522,1,0,0,0,514,516,3,52,
		26,0,515,514,1,0,0,0,515,516,1,0,0,0,516,517,1,0,0,0,517,519,3,204,102,
		0,518,520,3,152,76,0,519,518,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,
		512,1,0,0,0,521,515,1,0,0,0,522,523,1,0,0,0,523,527,5,30,0,0,524,526,3,
		86,43,0,525,524,1,0,0,0,526,529,1,0,0,0,527,525,1,0,0,0,527,528,1,0,0,
		0,528,530,1,0,0,0,529,527,1,0,0,0,530,531,5,31,0,0,531,85,1,0,0,0,532,
		533,3,88,44,0,533,535,5,37,0,0,534,536,3,48,24,0,535,534,1,0,0,0,535,536,
		1,0,0,0,536,87,1,0,0,0,537,538,5,6,0,0,538,541,3,18,9,0,539,541,5,2,0,
		0,540,537,1,0,0,0,540,539,1,0,0,0,541,89,1,0,0,0,542,551,5,15,0,0,543,
		552,3,92,46,0,544,545,3,204,102,0,545,546,3,92,46,0,546,552,1,0,0,0,547,
		548,3,52,26,0,548,549,3,204,102,0,549,550,3,92,46,0,550,552,1,0,0,0,551,
		543,1,0,0,0,551,544,1,0,0,0,551,547,1,0,0,0,552,553,1,0,0,0,553,557,5,
		30,0,0,554,556,3,94,47,0,555,554,1,0,0,0,556,559,1,0,0,0,557,555,1,0,0,
		0,557,558,1,0,0,0,558,560,1,0,0,0,559,557,1,0,0,0,560,561,5,31,0,0,561,
		91,1,0,0,0,562,563,5,27,0,0,563,565,5,41,0,0,564,562,1,0,0,0,564,565,1,
		0,0,0,565,566,1,0,0,0,566,567,3,154,77,0,567,568,5,38,0,0,568,569,5,28,
		0,0,569,570,5,20,0,0,570,571,5,29,0,0,571,93,1,0,0,0,572,573,3,96,48,0,
		573,575,5,37,0,0,574,576,3,48,24,0,575,574,1,0,0,0,575,576,1,0,0,0,576,
		95,1,0,0,0,577,578,5,6,0,0,578,581,3,98,49,0,579,581,5,2,0,0,580,577,1,
		0,0,0,580,579,1,0,0,0,581,97,1,0,0,0,582,585,3,116,58,0,583,585,5,26,0,
		0,584,582,1,0,0,0,584,583,1,0,0,0,585,593,1,0,0,0,586,589,5,35,0,0,587,
		590,3,116,58,0,588,590,5,26,0,0,589,587,1,0,0,0,589,588,1,0,0,0,590,592,
		1,0,0,0,591,586,1,0,0,0,592,595,1,0,0,0,593,591,1,0,0,0,593,594,1,0,0,
		0,594,99,1,0,0,0,595,593,1,0,0,0,596,597,5,5,0,0,597,601,5,30,0,0,598,
		600,3,102,51,0,599,598,1,0,0,0,600,603,1,0,0,0,601,599,1,0,0,0,601,602,
		1,0,0,0,602,604,1,0,0,0,603,601,1,0,0,0,604,605,5,31,0,0,605,101,1,0,0,
		0,606,607,3,104,52,0,607,609,5,37,0,0,608,610,3,48,24,0,609,608,1,0,0,
		0,609,610,1,0,0,0,610,103,1,0,0,0,611,614,5,6,0,0,612,615,3,56,28,0,613,
		615,3,106,53,0,614,612,1,0,0,0,614,613,1,0,0,0,615,618,1,0,0,0,616,618,
		5,2,0,0,617,611,1,0,0,0,617,616,1,0,0,0,618,105,1,0,0,0,619,620,3,18,9,
		0,620,621,5,34,0,0,621,626,1,0,0,0,622,623,3,16,8,0,623,624,5,41,0,0,624,
		626,1,0,0,0,625,619,1,0,0,0,625,622,1,0,0,0,625,626,1,0,0,0,626,627,1,
		0,0,0,627,628,3,152,76,0,628,107,1,0,0,0,629,637,5,22,0,0,630,632,3,152,
		76,0,631,630,1,0,0,0,631,632,1,0,0,0,632,638,1,0,0,0,633,638,3,110,55,
		0,634,636,3,112,56,0,635,634,1,0,0,0,635,636,1,0,0,0,636,638,1,0,0,0,637,
		631,1,0,0,0,637,633,1,0,0,0,637,635,1,0,0,0,638,639,1,0,0,0,639,640,3,
		46,23,0,640,109,1,0,0,0,641,643,3,52,26,0,642,641,1,0,0,0,642,643,1,0,
		0,0,643,644,1,0,0,0,644,646,3,204,102,0,645,647,3,152,76,0,646,645,1,0,
		0,0,646,647,1,0,0,0,647,648,1,0,0,0,648,650,3,204,102,0,649,651,3,52,26,
		0,650,649,1,0,0,0,650,651,1,0,0,0,651,111,1,0,0,0,652,653,3,18,9,0,653,
		654,5,34,0,0,654,659,1,0,0,0,655,656,3,16,8,0,656,657,5,41,0,0,657,659,
		1,0,0,0,658,652,1,0,0,0,658,655,1,0,0,0,658,659,1,0,0,0,659,660,1,0,0,
		0,660,661,5,19,0,0,661,662,3,152,76,0,662,113,1,0,0,0,663,664,5,8,0,0,
		664,665,3,152,76,0,665,115,1,0,0,0,666,668,3,120,60,0,667,669,3,118,59,
		0,668,667,1,0,0,0,668,669,1,0,0,0,669,676,1,0,0,0,670,676,3,122,61,0,671,
		672,5,28,0,0,672,673,3,116,58,0,673,674,5,29,0,0,674,676,1,0,0,0,675,666,
		1,0,0,0,675,670,1,0,0,0,675,671,1,0,0,0,676,117,1,0,0,0,677,678,5,32,0,
		0,678,680,3,98,49,0,679,681,5,35,0,0,680,679,1,0,0,0,680,681,1,0,0,0,681,
		682,1,0,0,0,682,683,5,33,0,0,683,119,1,0,0,0,684,687,3,168,84,0,685,687,
		5,27,0,0,686,684,1,0,0,0,686,685,1,0,0,0,687,121,1,0,0,0,688,697,3,124,
		62,0,689,697,3,184,92,0,690,697,3,130,65,0,691,697,3,142,71,0,692,697,
		3,132,66,0,693,697,3,134,67,0,694,697,3,136,68,0,695,697,3,138,69,0,696,
		688,1,0,0,0,696,689,1,0,0,0,696,690,1,0,0,0,696,691,1,0,0,0,696,692,1,
		0,0,0,696,693,1,0,0,0,696,694,1,0,0,0,696,695,1,0,0,0,697,123,1,0,0,0,
		698,699,5,32,0,0,699,700,3,126,63,0,700,701,5,33,0,0,701,702,3,128,64,
		0,702,125,1,0,0,0,703,704,3,152,76,0,704,127,1,0,0,0,705,706,3,116,58,
		0,706,129,1,0,0,0,707,708,5,62,0,0,708,709,3,116,58,0,709,131,1,0,0,0,
		710,711,5,4,0,0,711,720,5,30,0,0,712,715,3,140,70,0,713,715,3,32,16,0,
		714,712,1,0,0,0,714,713,1,0,0,0,715,716,1,0,0,0,716,717,3,204,102,0,717,
		719,1,0,0,0,718,714,1,0,0,0,719,722,1,0,0,0,720,718,1,0,0,0,720,721,1,
		0,0,0,721,723,1,0,0,0,722,720,1,0,0,0,723,724,5,31,0,0,724,133,1,0,0,0,
		725,726,5,32,0,0,726,727,5,33,0,0,727,728,3,128,64,0,728,135,1,0,0,0,729,
		730,5,9,0,0,730,731,5,32,0,0,731,732,3,116,58,0,732,733,5,33,0,0,733,734,
		3,128,64,0,734,137,1,0,0,0,735,741,5,11,0,0,736,737,5,11,0,0,737,741,5,
		64,0,0,738,739,5,64,0,0,739,741,5,11,0,0,740,735,1,0,0,0,740,736,1,0,0,
		0,740,738,1,0,0,0,741,742,1,0,0,0,742,743,3,128,64,0,743,139,1,0,0,0,744,
		745,5,27,0,0,745,746,3,148,74,0,746,747,3,146,73,0,747,751,1,0,0,0,748,
		749,5,27,0,0,749,751,3,148,74,0,750,744,1,0,0,0,750,748,1,0,0,0,751,141,
		1,0,0,0,752,753,5,3,0,0,753,754,3,144,72,0,754,143,1,0,0,0,755,757,3,148,
		74,0,756,758,3,146,73,0,757,756,1,0,0,0,757,758,1,0,0,0,758,145,1,0,0,
		0,759,762,3,148,74,0,760,762,3,116,58,0,761,759,1,0,0,0,761,760,1,0,0,
		0,762,147,1,0,0,0,763,775,5,28,0,0,764,769,3,150,75,0,765,766,5,35,0,0,
		766,768,3,150,75,0,767,765,1,0,0,0,768,771,1,0,0,0,769,767,1,0,0,0,769,
		770,1,0,0,0,770,773,1,0,0,0,771,769,1,0,0,0,772,774,5,35,0,0,773,772,1,
		0,0,0,773,774,1,0,0,0,774,776,1,0,0,0,775,764,1,0,0,0,775,776,1,0,0,0,
		776,777,1,0,0,0,777,778,5,29,0,0,778,149,1,0,0,0,779,781,3,16,8,0,780,
		779,1,0,0,0,780,781,1,0,0,0,781,783,1,0,0,0,782,784,5,42,0,0,783,782,1,
		0,0,0,783,784,1,0,0,0,784,785,1,0,0,0,785,786,3,116,58,0,786,151,1,0,0,
		0,787,788,6,76,-1,0,788,792,3,154,77,0,789,790,7,3,0,0,790,792,3,152,76,
		6,791,787,1,0,0,0,791,789,1,0,0,0,792,810,1,0,0,0,793,794,10,5,0,0,794,
		795,7,4,0,0,795,809,3,152,76,6,796,797,10,4,0,0,797,798,7,5,0,0,798,809,
		3,152,76,5,799,800,10,3,0,0,800,801,7,6,0,0,801,809,3,152,76,4,802,803,
		10,2,0,0,803,804,5,44,0,0,804,809,3,152,76,3,805,806,10,1,0,0,806,807,
		5,43,0,0,807,809,3,152,76,2,808,793,1,0,0,0,808,796,1,0,0,0,808,799,1,
		0,0,0,808,802,1,0,0,0,808,805,1,0,0,0,809,812,1,0,0,0,810,808,1,0,0,0,
		810,811,1,0,0,0,811,153,1,0,0,0,812,810,1,0,0,0,813,814,6,77,-1,0,814,
		818,3,158,79,0,815,818,3,156,78,0,816,818,3,202,101,0,817,813,1,0,0,0,
		817,815,1,0,0,0,817,816,1,0,0,0,818,830,1,0,0,0,819,826,10,1,0,0,820,821,
		5,38,0,0,821,827,5,27,0,0,822,827,3,194,97,0,823,827,3,196,98,0,824,827,
		3,198,99,0,825,827,3,200,100,0,826,820,1,0,0,0,826,822,1,0,0,0,826,823,
		1,0,0,0,826,824,1,0,0,0,826,825,1,0,0,0,827,829,1,0,0,0,828,819,1,0,0,
		0,829,832,1,0,0,0,830,828,1,0,0,0,830,831,1,0,0,0,831,155,1,0,0,0,832,
		830,1,0,0,0,833,834,3,116,58,0,834,835,5,28,0,0,835,837,3,152,76,0,836,
		838,5,35,0,0,837,836,1,0,0,0,837,838,1,0,0,0,838,839,1,0,0,0,839,840,5,
		29,0,0,840,157,1,0,0,0,841,851,3,160,80,0,842,844,3,166,83,0,843,845,3,
		118,59,0,844,843,1,0,0,0,844,845,1,0,0,0,845,851,1,0,0,0,846,847,5,28,
		0,0,847,848,3,152,76,0,848,849,5,29,0,0,849,851,1,0,0,0,850,841,1,0,0,
		0,850,842,1,0,0,0,850,846,1,0,0,0,851,159,1,0,0,0,852,856,3,162,81,0,853,
		856,3,170,85,0,854,856,3,192,96,0,855,852,1,0,0,0,855,853,1,0,0,0,855,
		854,1,0,0,0,856,161,1,0,0,0,857,862,5,26,0,0,858,862,3,164,82,0,859,862,
		3,188,94,0,860,862,5,69,0,0,861,857,1,0,0,0,861,858,1,0,0,0,861,859,1,
		0,0,0,861,860,1,0,0,0,862,163,1,0,0,0,863,864,7,7,0,0,864,165,1,0,0,0,
		865,866,5,27,0,0,866,167,1,0,0,0,867,868,5,27,0,0,868,869,5,38,0,0,869,
		870,5,27,0,0,870,169,1,0,0,0,871,872,3,172,86,0,872,873,3,174,87,0,873,
		171,1,0,0,0,874,887,3,184,92,0,875,887,3,124,62,0,876,877,5,32,0,0,877,
		878,5,42,0,0,878,879,5,33,0,0,879,887,3,128,64,0,880,887,3,134,67,0,881,
		887,3,136,68,0,882,884,3,120,60,0,883,885,3,118,59,0,884,883,1,0,0,0,884,
		885,1,0,0,0,885,887,1,0,0,0,886,874,1,0,0,0,886,875,1,0,0,0,886,876,1,
		0,0,0,886,880,1,0,0,0,886,881,1,0,0,0,886,882,1,0,0,0,887,173,1,0,0,0,
		888,893,5,30,0,0,889,891,3,176,88,0,890,892,5,35,0,0,891,890,1,0,0,0,891,
		892,1,0,0,0,892,894,1,0,0,0,893,889,1,0,0,0,893,894,1,0,0,0,894,895,1,
		0,0,0,895,896,5,31,0,0,896,175,1,0,0,0,897,902,3,178,89,0,898,899,5,35,
		0,0,899,901,3,178,89,0,900,898,1,0,0,0,901,904,1,0,0,0,902,900,1,0,0,0,
		902,903,1,0,0,0,903,177,1,0,0,0,904,902,1,0,0,0,905,906,3,180,90,0,906,
		907,5,37,0,0,907,909,1,0,0,0,908,905,1,0,0,0,908,909,1,0,0,0,909,910,1,
		0,0,0,910,911,3,182,91,0,911,179,1,0,0,0,912,915,3,152,76,0,913,915,3,
		174,87,0,914,912,1,0,0,0,914,913,1,0,0,0,915,181,1,0,0,0,916,919,3,152,
		76,0,917,919,3,174,87,0,918,916,1,0,0,0,918,917,1,0,0,0,919,183,1,0,0,
		0,920,921,5,10,0,0,921,927,5,30,0,0,922,923,3,186,93,0,923,924,3,204,102,
		0,924,926,1,0,0,0,925,922,1,0,0,0,926,929,1,0,0,0,927,925,1,0,0,0,927,
		928,1,0,0,0,928,930,1,0,0,0,929,927,1,0,0,0,930,931,5,31,0,0,931,185,1,
		0,0,0,932,933,3,16,8,0,933,934,3,116,58,0,934,937,1,0,0,0,935,937,3,190,
		95,0,936,932,1,0,0,0,936,935,1,0,0,0,937,939,1,0,0,0,938,940,3,188,94,
		0,939,938,1,0,0,0,939,940,1,0,0,0,940,187,1,0,0,0,941,942,7,8,0,0,942,
		189,1,0,0,0,943,945,5,62,0,0,944,943,1,0,0,0,944,945,1,0,0,0,945,946,1,
		0,0,0,946,948,3,120,60,0,947,949,3,118,59,0,948,947,1,0,0,0,948,949,1,
		0,0,0,949,191,1,0,0,0,950,951,5,3,0,0,951,952,3,144,72,0,952,953,3,46,
		23,0,953,193,1,0,0,0,954,955,5,32,0,0,955,956,3,152,76,0,956,957,5,33,
		0,0,957,195,1,0,0,0,958,974,5,32,0,0,959,961,3,152,76,0,960,959,1,0,0,
		0,960,961,1,0,0,0,961,962,1,0,0,0,962,964,5,37,0,0,963,965,3,152,76,0,
		964,963,1,0,0,0,964,965,1,0,0,0,965,975,1,0,0,0,966,968,3,152,76,0,967,
		966,1,0,0,0,967,968,1,0,0,0,968,969,1,0,0,0,969,970,5,37,0,0,970,971,3,
		152,76,0,971,972,5,37,0,0,972,973,3,152,76,0,973,975,1,0,0,0,974,960,1,
		0,0,0,974,967,1,0,0,0,975,976,1,0,0,0,976,977,5,33,0,0,977,197,1,0,0,0,
		978,979,5,38,0,0,979,980,5,28,0,0,980,981,3,116,58,0,981,982,5,29,0,0,
		982,199,1,0,0,0,983,998,5,28,0,0,984,991,3,18,9,0,985,988,3,116,58,0,986,
		987,5,35,0,0,987,989,3,18,9,0,988,986,1,0,0,0,988,989,1,0,0,0,989,991,
		1,0,0,0,990,984,1,0,0,0,990,985,1,0,0,0,991,993,1,0,0,0,992,994,5,42,0,
		0,993,992,1,0,0,0,993,994,1,0,0,0,994,996,1,0,0,0,995,997,5,35,0,0,996,
		995,1,0,0,0,996,997,1,0,0,0,997,999,1,0,0,0,998,990,1,0,0,0,998,999,1,
		0,0,0,999,1000,1,0,0,0,1000,1001,5,29,0,0,1001,201,1,0,0,0,1002,1003,3,
		116,58,0,1003,1004,5,38,0,0,1004,1005,5,27,0,0,1005,203,1,0,0,0,1006,1011,
		5,36,0,0,1007,1011,5,0,0,1,1008,1011,5,88,0,0,1009,1011,4,102,7,0,1010,
		1006,1,0,0,0,1010,1007,1,0,0,0,1010,1008,1,0,0,0,1010,1009,1,0,0,0,1011,
		205,1,0,0,0,120,213,219,225,241,245,248,257,267,271,275,279,286,294,305,
		309,313,321,331,344,348,355,359,366,378,382,388,392,396,401,404,407,414,
		431,438,454,465,469,473,477,496,502,504,508,512,515,519,521,527,535,540,
		551,557,564,575,580,584,589,593,601,609,614,617,625,631,635,637,642,646,
		650,658,668,675,680,686,696,714,720,740,750,757,761,769,773,775,780,783,
		791,808,810,817,826,830,837,844,850,855,861,884,886,891,893,902,908,914,
		918,927,936,939,944,948,960,964,967,974,988,990,993,996,998,1010
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
