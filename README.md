Compilers_Lab1

Напишите программу, которая в качестве входа принимает произвольное регулярное выражение, и выполняет 
следующие преобразования: 
1) По регулярному выражению строит НКА.
2) По НКА строит эквивалентный ему ДКА. 
3) По ДКА строит эквивалентный ему КА, имеющий наименьшее возможное количество состояний. 
Указание. Воспользоваться алгоритмом, приведенным по адресу 
http://neerc.ifmo.ru/wiki/index.php?title=Минимизация_ДКА,_алгоритм_за_O(n%5E2)_с_построением_пар_разл
ичимых_состояний
4) Моделирует минимальный КА для входной цепочки из терминалов исходной грамматики


CCLab2_2

Устранение левой рекурсии.
Определение. Нетерминал A КС-грамматики G = (, , P, S) называется рекурсивным, если A =>+ A для 
некоторых  и . Если  = , то A называется леворекурсивным. Аналогично, если  = , то А называется 
праворекурсивным. Грамматика, имеющая хотя бы один леворекурсивный нетерминал, называется леворекурсивной. Аналогично определяется праворекурсивная грамматика. Грамматика, в которой все 
нетерминалы, кроме, быть может, начального символа, рекурсивные, называется рекурсивной.
Некоторые из алгоритмов разбора не могут работать с леворекурсивными грамматиками. Можно показать, что 
каждый КС-язык определяется хотя бы одной не леворекурсивной грамматикой. 
Постройте программу, которая в качестве входа принимает приведенную КС-грамматику G = (, , P, S) и 
преобразует ее в эквивалентную КС-грамматику G' без левой рекурсии

Устранение недостижимых символов.
Определение. Символ X     назовем недостижимым в КС-грамматике G = (, , P, S), если Х не 
появляется ни в одной выводимой цепочке.
Постройте программу, которая в качестве входа принимает произвольную КС-грамматику G = (, , P, S) и 
преобразует ее в эквивалентную КС-грамматику G' = (', ', P', S'), не содержащую недостижимых символов.

Lab3
Грамматика G1
Рассматривается грамматика выражений отношения с правилами
<выражение> ->
<простое выражение> | 
<простое выражение> <операция отношения> <простое выражение>
<простое выражение> ->
<терм> | 
<знак> <терм> | 
<простое выражение> <операция типа сложения> <терм>
<терм> ->
<фактор> | 
<терм> <операция типа умножения> <фактор>
<фактор> ->
<идентификатор> | 
<константа> | 
( < простое выражение > ) | 
not <фактор>
<операция отношения> ->
= | <> | < | <= | > | >=
<знак> ->
+ | -
<операция типа сложения> ->
+ | - | or
<операция типа умножения> ->
* | / | div | mod | and
Замечания.
1. Нетерминалы <идентификатор> и <константа> - это лексические единицы (лексемы), которые
оставлены неопределенными, а при выполнении лабораторной работы можно либо рассматривать их
как терминальные символы, либо определить их по своему усмотрению и добавить эти определения.
2. Терминалы not, or, div, mod, and - ключевые слова (зарезервированные).
3. Терминалы ( ) - это разделители и символы пунктуации.
4. Терминалы = <> < <= > >= + - * / - это знаки операций.
5. Нетерминал <выражение> - это начальный символ грамматики.

Дополнить грамматику блоком, состоящим из последовательности операторов присваивания. Для реализации
предлагаются два варианта расширенной грамматики.
Вариант в стиле Алгол-Паскаль.
<программа> -> 
<блок>
<блок> ->
begin <список операторов> end
<список операторов>
<оператор> | <список операторов> ; <оператор>
<оператор> ->
<идентификатор> = <выражение>
9
Вариант в стиле Си.
<программа> -> 
<блок>
<блок> ->
{ <список операторов> }
<список операторов>
<оператор> <хвост>
<хвост> ->
; <оператор> <хвост> | ε
Первый вариант содержит левую рекурсию, которая должна быть устранена. Второй вариант не содержит
левую рекурсию, но имеет ε-правило. В обоих вариантах точка с запятой (;) ставится между операторами.
Теперь начальным символом грамматики становится нетерминал <программа>. Оба варианта содержат
цепное правило <программа> -> <блок>. Можно начальным символом грамматики назначить нетерминал
<блок>. А можно <блок> считать оператором, т. е.
<оператор> ->
<идентификатор> = <выражение> |
<блок>
В последнем случае возможна конструкция с вложенными блоками. Если между символом присваивания (=) и
символом операции отношения (=) возникает конфликт, то можно для любого из них ввести новое
изображение, например, :=, <-, == и т. п.
Для модифицированной грамматики написать программу нисходящего синтаксического анализа с
использованием метода рекурсивного спуска.
+ Тут же
Разработать, тестировать и отладить программу синтаксического анализа 
в соответствии с предложенным вариантом грамматики. 
2. Включить в программу синтаксического анализ семантические действия 
для реализации синтаксически управляемого перевода инфиксного 
выражения в обратную польскую нотацию.

CC_Course
Разработать компилятор языка Go в MCIL. Компилятор написан на языке C#. Компилятор должен быть достаточен для выполнения
программ сортировки пузырьком и reverse односвязного списка.

